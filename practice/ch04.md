## 第四章 表达式
### 练习4.1
  question:表达式5+10*\20/2的求值结果是多少？  
  answer:  
  > 105   

### 练习4.2  
  question: 根据4.12节中的表，在下述表达式的合理位置添加括号，使得添加括号后运算对象的组合顺序与添加括号前一致。  
  >(a) `*vec.begin()`  
  >(b) `*vec.begin() + 1`  
  answer:  
  >(a) `*(vec.begin())`  
  >(b) `(*(vec.begin())) + 1`

### 练习4.3 
  question:C++语言没有明确规定大多数二元运算符的求值顺序，给编译器优化留下了余地。这种策略实际上是在代码生成效率和程序潜在缺陷之间进行了权衡，你认为这可以接受吗？请说出你的理由。 
  answer:  
  >可以接受。C++的设计思想是尽可能地“相信”程序员，将效率最大化。然而这种思想却有潜在的危害，就是无法控制程序员自身引发地错误，因此Java地诞生也是必然地，Java的思想就是尽可能地“不相信”程序员。

### 练习4.4
  question:在下面的表达式中添加括号，说明其求值的过程及其最终结果。编写程序编译该（不加括号的）表达式并输出其结果验证之前的推断。  
  `12 / 3 * 4 + 5 * 15 + 24 % 4 / 2`
  answer:  
  > `((12 / 3) * 4) + (5 * 15) + ((24 % 4) / 2)`  结果为91

### 练习4.5  
  question:写出谢列表达式的求值结果  
  >(a) `-30 * 3 + 21 / 5`  
  >(b) `-30 + 3 * 21 / 5`  
  >(c) `30 / 3 * 21 % 5` 
  >(d) `-30 / 3 * 21 %4`  
  answer:  
  >(a) -86   
  >(b) -18   
  >(c) 0  
  >(d) -2

### 练习4.6
  question:写出一条表达式用于确定一个整数是奇数还是偶数。  
  answer:  
  >`if(num % 2 == 0){} `  

### 练习4.7
  question:溢出是何定义？写出三条导致溢出的表达式。  
  answer:  
  > 当计算的结果超出该类型所能表示的最大范围时就会溢出。  
  > `char a = 'a' + 128;`  
  > `unsigned int a = -1;`  
  > `size_t a = -1;`   

### 练习4.8
  question:说明在逻辑与、逻辑或及相等性运算符中运算对象的求值顺序。  
  answer:  
  >逻辑与和逻辑或都是短路求值，相等性没有定义  

### 练习4.9
  question:解释在下面的if语句中条件部分的判断过程。  
  ```cpp
  const char *p = "Hello World";
  if(cp && *cp) 
  ```
  answer:  
  > 首先判断cp是否为空，发现不为空，然后判断\*cp是否为空，也不为空，所以该表达式的结果时true

### 练习4.10
  question:为while循环写一个条件，使其从标准输入中读取整数，遇到42时停止。
  answer：  
```cpp
#include <iostream>

using std::cin;
using std::cout;
using std::endl;

int main(){
	int a;
	while(cin>>a && a != 42) 
		cout<<a<<endl;
	return 0;
}
```

### 练习4.11
  question:书写一条表达式用于测试4个值a b c d的关系，确保a大于b，b大于c，c大于d 
  answer:   
  >`a > b && b > c && c > d`  
  
### 练习4.12
  question:假设i、j和k是三个整数，说明表达式i!=j<k的含义。  
  answer:  
  >如果i和j相等，则k大于0即为真；如果i和不相等，则k大于1即为真  


### 练习4.13  
  question:在下述语句中，当赋值完成后i和d的值分别是多少？  
  `int i; double d;`
  >(a) `d = i = 3.5;`  
  >(b) `i = d = 3.5;`  
  answer:  
  >(a) i=3，d=3.0  
  >(b) i=3,d=3.5   

### 练习4.14 
  question:执行下述if语句后将发生什么情况？
  ```cpp
  if(42 = i) //....
  if(i = 42) //....
  ```
  answer:  
  > `if(42=i)` 编译器报错  
  > `if(i=42)` 条件表达式结果为true  

### 练习4.15 
  question:下面的赋值是非法的，为什么？应该如何修改？  
  ```cpp
  double dval;
  int ival;
  int *pi;
  dval = ival = pi = 0;
  ```
  answer:  
  > 首先pi被赋值为空指针，然后让pi去赋值ival，也就是让int\*去赋值int这明显是错误。  

### 练习4.16  
  question: 尽管下面的语句合法，但它们实际执行的行为可能和预期并不一样？为什么？  
  >(a) `if (p = getPtr() != 0)`  
  >(b) `if(i = 1024)`  
  answer:  
  >(a) 赋值运算符的优先级低，应该加一个括号  
  >(b) 这里可能是想表达`i==1024`，如果是`i=1024`则条件表达式的结果永远为真。  

### 练习4.17
  question:说明前置运算符和后置运算符的区别。  
	answer:  
  >前置运算符先返回值再加1，后置运算符是先加1再返回值。   

### 练习4.18  
  question:如果第132页那个输出vector兑现个元素的while循环使用前置递增运算符，将得到什么结果？  
	answer:  
  >从第二个元素开始输出，并且最后一个输出是未定义的。   


### 练习4.19  
  question:假设ptr的类型是指向int的指针、vec的类型是vector<int\>、ival的类型是int,说明下面的表达式是何含义？如果有表达式不正确，为什么？应该如何修改？    
  >(a) `ptr != 0 && *ptr++` 
  >(b) `ival++ && ival`  
  >(c) `vec[ival++] <= vec[ival]`  
  answer:  
	>(a) 判断ptr是否是空指针，不是则判断ptr指向的内容是不是空并且ptr++  
	>(b) 判断ival的值是否为真，然后ival++，再判断ival的值是否为真  
	>(c) 表达式是未定义的,可以改为`vec[ival] <= vec[ival+1];++ival;`  

### 练习4.20  
  question:假设iter的类型是vector\<string\>::iterator,说明下面的表达式是否合法。如果合法，表达式的含义是什么？如果不合法，错在何处？   
  >(a)`*iter++`   
  >(b)`(*iter)++`  
  >(c)`*iter.empty()`  
  >(d)`iter->empty()`  
  >(e)`++*iter`  
  >(f)`iter++->empty()`  
  
  answer:  
  >(a)合法，返回迭代器所指的元素，然后迭代器自增  
  >(b)不合法，string没有自增操作  
  >(c)不合法，应该加括号。  
  >(d)合法，判断iter所指向的string是否为空  
  >(e)不合法，string没有自增操作  
  >(f)合法，判断iter所指向元素是否为空，然后自增   


  
 
	










  
