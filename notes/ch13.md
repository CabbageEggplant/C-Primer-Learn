## 第十三章 拷贝控制

+ 当定义一个类时，显式或隐式地指定在此类型地对象拷贝、移动、赋值和销毁时做什么。通过定义五种特殊地成员函数来控制这些操作：拷贝构造函数、拷贝赋值运算符、移动构造函数、移动赋值运算符、析构函数。

+ 拷贝和移动构造函数定义了当用同类型地另一个对象初始化本对象时做什么。拷贝和移动赋值运算符定义了一个对象赋予同类型另一个对象时做什么。析构函数定义了当此类型对象销毁时做什么

### 13.1 拷贝、赋值与销毁

#### 13.1.1 拷贝构造函数

+ 如果一个构造函数的第一个参数是自身类型的引用，且任何额外参数都有默认值，则此构造函数是拷贝构造函数

+ 可以定义一个接受非const引用的拷贝构造函数，但此参数几乎总是一个const的引用。拷贝构造函数在几种情况下都会被隐式使用，因此其不应该是explicit

+ 如果我们没有为一个类定义拷贝构造函数，编译器会为我们定义一个。与合成的默认构造函数不同，即使我们定义了其他构造函数，编译器也会为我们合成一个拷贝构造函数

+ 一般而言，合成的拷贝构造函数会将其参数的成员逐个拷贝到正在创建的对象中。编译器从给定对象中依次将每个非static成员拷贝到正在创建的对象中

+ 每个成员的类型决定它如何拷贝：对类类型的成员，会使用其拷贝构造函数来拷贝；内置类型则直接拷贝。虽然不能直接拷贝一个数组，但合成的拷贝构造函数会逐元素地拷贝一个数组类型的成员

+ 下面的拷贝构造函数与合成的拷贝构造函数等价
  
  ```cpp
  Sales_data::Sales_data(const Sales_data &orig):bookNo(orig.bookNo),
  units_sold(orig.ubits_sold),
  revenue(orig.revenue)
  {}
  ```

+ 当使用直接初始化时，我们实际上是要求编译器使用普通的函数匹配来选择与我们提供的参数最匹配的构造函数。当我们使用拷贝初始化时，我们要求编译器将右侧运算对象拷贝到正在创建的对象中，如果需要的话还要进行类型转换。
  
  ```cpp
  string dots(10,'.'); //直接初始化
  string s(dots);//直接初始化
  string s2 = dots; //拷贝初始化
  string null_book = "9-999-99999-9"; //拷贝初始化
  string nines = string(100,'9'); //拷贝初始化
  ```

+ 拷贝初始化通常使用拷贝构造函数来完成，如果一个类有一个移动构造函数，则拷贝初始化有时会使用移动构造函数而非拷贝构造函数

+ 拷贝初始化发生的情况：
  
  + 使用=定义变量时
  
  + 将一个对象作为实参传递给一个非引用类型的形参
  
  + 从一个返回类型为非引用类型的函数返回一个对象
  
  + 用花括号列表初始化一个数组中的元素或一个聚合类中的成员

+ 某些类型还会对它们所分配的对象使用拷贝初始化，例如，当初始化标准库容器或调用其insert或push成员时，容器会对其元素进行拷贝初始化。与之相对，用emplace成员创建的元素都进行直接初始化

+ 拷贝构造函数被用来初始化非引用类类型参数，这一特性解释了为什么拷贝构造函数自己的参数必须是引用类型。如果其参数不是引用类型，则调用永远也不会成功——为了调用拷贝构造函数，我们必须拷贝它的实参，但为了拷贝实参，我们又必须调用拷贝构造函数，如此无限循环

+ 在拷贝初始化过程中，编译器可以（但不是必须）跳过拷贝/移动构造函数，直接创建对象。例如,编译器被允许将下面的代码`string null_book="9-999-99999-9";`改写为`string null_book("9-999-99999-9");`。但是即便编译器略过了拷贝/移动构造函数，但在这个程序点上，拷贝/移动构造函数必须是存在且可访问的（例如不能是private）

#### 13.1.2 拷贝赋值运算符

+ 重载运算符本质上是函数，其名字由operator关键字后接表示要定义的运算符的符号组成。因此，赋值运算符就是一个名为operator=的函数。

+ 重载运算符的参数表示运算符的运算对象，某些运算符，包括赋值运算符，必须定义为成员函数，如果一个运算符是一个成员函数，其左侧运算对象就绑定到隐式的this参数

+ 为了与内置类型的赋值保持一致，赋值运算符通常返回一个指向其左侧运算对象的引用。标准库通常要求保存在容器中的类型要具有赋值运算符，其返回值是左侧运算对象的引用

+ 如果一个类未定义自己的拷贝赋值运算符，编译器会为它生成一个合成拷贝赋值运算符，会将右侧运算对象的每个非static成员赋予左侧运算对象的对应成员。合成拷贝赋值运算符返回一个指向其左侧运算对象的引用。

+ 下面的代码等价于Sales_data得到合成拷贝赋值运算符
  
  ```cpp
  Sales_data& Sales_data::operator=(const Sales_data &rhs){
      bookNo = rhs.bookNo;
      units_sold = rhs.units_sold;
      revenus = rhs.revenus;
      return *this;
  }
  ```

+ 调用的是拷贝构造函数还是赋值运算符，主要是看是否有新的对象实例产生，如果产生了新的对象实例，那调用的就是拷贝构造函数，如果没有，那就是对已有的对象赋值，调用的是拷贝赋值运算符

#### 13.1.3 析构函数

+ 构造函数初始化对象的非static数据成员，还可能做一些其他工作。析构函数释放对象使用的资源，并销毁对象的非static数据成员

+ 析构函数名字由波浪号接类名构成，没有返回值，也不接受参数。因此其不能被重载

+ 在一个析构函数中，首先执行函数体，然后销毁成员，按初始化顺序的逆序销毁

+ 析构部分是隐式的，成员销毁时发生什么完全依赖于成员的类型。销毁类类型的成员需要执行成员自己的析构函数。内置类型没有析构函数，因此销毁内置类型成员什么也不需要做

+ 隐式销毁一个内置指针的成员不会delete它所指向的对象

+ 无论何时一个对象被雄安会，就会自动调用其析构函数：
  
  + 变量在离开作用域时被销毁
  + 当一个对象被销毁时，其成员被销毁
  + 容器（无论时标准库容器还是数组）被销毁时，其元素被销毁
  + 对于动态分配的对象，当对指向它的指针应用delete运算时被销毁
  + 对于临时对象，当创建它的完整表达式结束时被销毁

+ 由于析构函数自动运行，我们的程序可以按需要分配资源，而（通常）无须担心何时释放这些资源

+ 当指向一个对象的引用或指针离开作用域时，析构函数不会执行

+ 当一个类未定义自己的析构函数时，编译器会为它定义一个合成析构函数。对于某些类，合成析构函数被用来阻止该类型的对象被销毁，如果不是这种情况，合成析构函数的函数体为空

+ 下面的代码等价于Sales_data的合成析构函数
  
  ```cpp
  class Sales_data{
  public:
      //成员会被自动销毁，除此之外不需要做其他事情
      ~Sales_data(){}
  };
  ```

+ 成员在析构函数体之后的隐含的析构阶段中被销毁

#### 13.1.4 三/五法则

+ 对析构函数的需求要比对拷贝函数或赋值运算符的需求更明显。如果一个类需要一个析构函数，我们几乎可以肯定它也需要一个拷贝构造函数和一个拷贝赋值运算符

+ 如果一个类需要一个拷贝构造函数，几乎可以肯定它也需要一个拷贝赋值运算符

#### 13.1.5 使用=default

+ 当我们在类内用=default修饰成员的声明时，合成的函数将隐式地声明为内联地，如果我们不希望合成的成员时是内联函数，应该只对成员地类外定义使用=deafult

+ 我们只能对具有合成版本地的员函数使用=default

+ 大多数类应该定义默认构造函数、拷贝构造函数和拷贝赋值运算符，无论是隐式还是显式

+ C++11中可以通过将拷贝构造函数和拷贝赋值运算符定义为删除的函数来阻止拷贝。删除函数：我们虽然声明了它们，但不能以任何方式使用它们。在函数的参数列表后面加上=delete来指出我们希望将它定义为删除的

+ 与=deafult不同的是，=delete必须出现在函数第一次声明的时候。这个差异和这些声明在逻辑上是吻合的。一个默认成员只影响为这个成员而生成的代码，因此=default知道编译器生成代码时才需要，而另一方面，编译器需要知道一个函数是删除的，以便禁止试图使用它的操作。

+ 不能删除析构函数。对于一个删除了析构函数的类型，编译器将不允许定义该类型的变量或创建该类的临时对象。

+ 对于删除了析构函数的类，虽然不能定义这种类型的变量或成员，但可以动态分配这些类型的对象，不过不能释放这些对象

+ 对某些类来说，编译器将这些合成的成员定义为删除的函数：
  
  + 如果类的某个成员的析构函数是删除的或不可访问的(private)，则类的合成析构函数被定义为删除的
  
  + 如果类的某个成员的拷贝构造函数是删除的或不可访问的，则类的合成拷贝构造函数被定义为删除的。如果类的某个成员的析构函数是删除的或不可访问的，则类合成的拷贝构造函数也被定义为删除的
  
  + 如果类的某个成员的拷贝赋值运算符是删除的或不可访问的，或是类有一个const的或引用成员，则类的合成拷贝赋值运算符被定为删除的
  
  + 如果类的某个成员的析构函数是删除的或不可访问的的，或是类有一个引用成员，它没有类内初始化器，或是类有一个const成员，没有类内初始化器且其类型未显式定义默认构造函数，则该类的默认构造函数被定义为删除的

+ 如果一个类有数据成员不能默认构造、拷贝、赋值或销毁，则对应的成员函数将被定义为删除的

+ 希望阻止拷贝的类应该使用=delete来定义它们自己的拷贝构造函数和拷贝赋值运算符，而不应该将它们声明为private的

### 13.2 拷贝控制和资源管理

+ 定义拷贝操作，使类的行为看起来像一个值或者像一个指针
  
  + 类的行为像一个值，意味着它应该也有自己的状态。当我们拷贝一个像值的对象时，副本和元对象是完全独立的。改变副本不会对元对象有任何影响，反之亦然
  
  + 行为像指针的类则共享状态。当我们拷贝一个这种类的对象时，副本和原对象使用相同的底层数据。改变副本也会改变原对象，反之亦然。

#### 13.2.1 行为像值的类

+ 编写赋值运算符的时候，有两点需要记住：
  
  + 如果将一个对象赋予它自身，赋值运算符必须能正常工作
  
  + 大多数赋值运算符中组合了析构函数和拷贝构造函数的工作

+ 常见的赋值运算符函数
  
  ```cpp
  HasPtr& HasPtr::operator=(const HasPtr &rhs){
      auto newp = new string(*rhs.ps);//拷贝底层string
      delete ps;//释放旧内存
      ps = newp;//从右侧运算对象拷贝数据到本对象
      i = rhs.i;
      return *this;//返回本对象
  }
  ```



#### 13.2.2 定义行为像指针的类

+ 令一个类展现类似指针的行为的最好方法是使用shared_ptr来管理类中的资源

+ 有时希望直接管理资源，在这种情况下，使用引用计数

+ 引用计数的工作方式：
  
  + 除了初始化对象外，每个构造函数（拷贝构造函数除外）还要创建一个引用计数，用来记录有多少对象与正在创建的对象共享状态。当我们创建一个对象时，只有一个对象共享状态，因此将计数器初始化为1
  
  + 拷贝构造函数不分配新的计数器，而是拷贝给定对象的数据成员，包括计数器。拷贝构造函数递增共享的计数器，指出给定对象的状态又被一个新用户所共享
  
  + 析构函数递减计数器，指出共享状态的用户少了一个。如果计数器变为0，则析构函数释放状态
  
  + 拷贝赋值运算符递增右侧运算对象的计数器，递减左侧运算对象的计数器。如果左侧运算对象的计数器变为0，意味着它的共享状态没有用户了，拷贝赋值运算符就必须销毁状态

+ 将计数器保存在动态内存中



### 13.3 交换操作

+ 对于那些与重排元素顺序的算法一起使用的类，定义swap是非常重要的

+ 如果一个类定义了自己的swap，那么算法使用类自定义版本，否则，算法将使用标准库定义的swap

+ 与拷贝控制成员不同，swap并不是必须的，但是对于分配了资源的类，定义swap可能是一种很重要的优化手段

+ swap函数应该调用swap，而不是std::swap，如果存在类型特定的swap把呢不能，其匹配程度会优于std中定义的版本，如果不存在类型特定的版本，则会使用std中的版本（假定作用域中有using 声明）

+ 定义swap的类通常用swap来定义它们的赋值运算符，其使用了一种名为拷贝并交换的计技术，将左侧运算对象与右侧运算对象的一个副本进行交换。
  
  ```cpp
  HasPtr& HasPtr::operator=(HasPtr rhs){//注意这里不是引用
      swap(*this,rhs);
      return *this;//rhs被销毁，从而delete了rhs中的指针
  }
  ```

+ 当赋值运算符结束时，rhs被销毁，HasPtr中的析构函数将执行，此析构函数delete了rhs现在指向的内存，也就是释放掉了左侧运算对象中原来的内存，这个技术的有趣之处在于自动处理了自赋值情况而且天然就是异常安全的



### 13.4 拷贝控制实例

### 13.5 动态内存管理类

+ 移动构造函数通常是将资源从给定对象”移动“而不是拷贝到正在创建的对象

+ 可以假定string的移动构造函数进行了指针的拷贝，而不是为字符串分配内存空间然后拷贝字符

+ move标准函数定义在头文件utility中。当reallocate在新内存中构造string时，它必须调用move表示希望使用string的移动构造函数，如果漏掉了move调用，将会使用string的拷贝构造函数。通常不为move提供一个using声明。当我们使用move时，直接调用std::move而不是move

### 13.6 对象移动

+ 某些情况下，对象拷贝后就立即被销毁了，此时，移动而非拷贝对象会大幅度提升性能

+ 在重新分配内存的过程中，从旧内存将元素拷贝到新内存是不必要的，更好的方式是移动元素。使用移动而不是拷贝的另一个原因源于IO类或unique_ptr这样的类，都包含不能被共享的资源（如指针或IO缓冲），因此这些类型的对象不能拷贝但可以移动

+ C++11中，我们可以用容器保存不可拷贝的类型，只要它们能被移动即可

#### 13.6.1 右值引用

+ 右值引用就是必须绑定到右值的引用，通过&&获得右值引用，右值引用的一个重要性质是只能绑定到一个将要销毁的对象。

+ 一般而言，一个左值表达式表示的是一个对象的身份，而一个右值表达式表示的是对象的值

+ 左值引用不能绑定到要求转换的表达式、字面常量或是返回右值的表达式。右值引用则有着完全相反的绑定特性，可以将一个右值引用绑定到这类表达式上，但是不能将一个右值引用直接绑定到一个左值上
  
  ```cpp
  int i = 42;
  int &r = i; //正确，r引用
  int &&rr = i;//错误，不能将一个右值引用绑定到一个左值上
  int &r2 = i * 42; //错误,i*42是一个右值
  const int &r3 = i * 42;//正确，可以将一个const的引用绑定到一个右值上
  int &&rr2 = i * 42;//正确，将rr2绑定到乘法结果上
  ```

+ 左值有持久的状态，而右值要么是字面常量，要么是在表达式求值过程中创建的临时对象

+ 右值引用：
  
  + 所引用的对象将要被销毁
  
  + 该对象没有其他用户
  
  这意味着使用右值引用的代码可以自由接管所引用的对象的资源

+ 变量表达式都是做猜测，因此不能将一个右值引用绑定到一个右值引用类型的变量上，毕竟变量是左值

+ 虽然不能将一个右值引用直接绑定到一个左值上，但我们可以显式地将一个左值转换为对应的右值引用类型。move调用告诉编辑器：我们有一个左值，但我们希望像一个右值一样处理它。必须要知道，调用move就意味着承诺，除了对rr1赋值或销毁它外，我们将不再使用它，调用move后，不能对移后源对象的值做任何假设
  
  `int &&rr3 = std::move(rr1);`

+ 可以销毁一个移后源对象，也可以赋予它新值，但是不能使用一个移后源对象的值

+ 使用move的代码应该使用std::move而不是move，这样可以避免潜在的名字冲突



#### 13.6.2 移动构造函数和移动赋值运算符

+ 为了让我们自己的类型支持移动操作，需要为其定义移动构造函数和移动赋值运算符

+ 移动构造函数的第一个参数是该类型的一个引用，并且是右值引用，与拷贝构造函数一样，任何额外的参数都必须有默认实参。

+ 除了完成资源移动，移动构造函数还必须确保移后源对象处于这样一个状态——销毁它是无害的。一旦资源完成移动，原对象必须不再指向被移动的资源——这些资源的所有权已经归属新创建的对象
  
  ```cpp
  StrVec::StrVec(StrVec &&s) noexcept :elements(s.elements),first_free(s.first_free),cap(s.cap){
      //令s进入这样一个状态，对其运行析构函数是安全的
      s.elements = s.first_free = s.cap = nullptr;
  }
  ```

+ 不抛出异常的移动构造函数和移动赋值运算符必须标记为noexcept

+ 必须在类头文件的声明中和定义中都指定noexcept

+ 当我们编写一个移动操作时，必须确保移后源对象进入一个可析构的状态

+ 与拷贝操作不同，编译器根本不会为某些类合成移动操作，特别时，如果一个类定义了自己的拷贝构造函数、拷贝赋值运算符或者析构函数，编译器就不会为它合成移动公祖奥函数和移动赋值运算符了。因此，某些类就没有移动构造函数或移动赋值运算符。如果一个类没有移动操作，通过正常的函数匹配，类会使用对应的拷贝操作来代替移动操作

+ 只有当一个类没有定义任何自己版本的拷贝控制成员，且类的每个非static数据成员都可以移动时，编译器才会为它合成移动构造函数或移动赋值运算符。

+ 与拷贝操作不同，移动操作永远不会隐式定义为删除的函数，但如果显式地要求编译器生成=default地移动操作，且编译器不能移动所有成员，则编译器会将移动操作定义为删除的函数

+ 合成的移动操作定义为删除的函数：
  
  + 移动构造函数被定义为删除的函数的条件是：有类成员定义了自己的拷贝构造函数且未定义移动构造函数或者是有类成员未定义自己的拷贝构造函数且编译器不能为其合成移动构造函数。移动赋值运算符类似
  
  + 如果有类成员的移动构造函数或移动赋值运算符被定义为删除的或不可访问的，则类的移动构造函数或移动赋值运算符被定义删除的
  
  + 如果类的析构函数被定为删除的或不可访问的，则类的移动构造函数被定义为删除的
  
  + 如果有类成员是const或引用，则类的移动赋值运算符被定义为删除的

+ 如果类定义了一个移动构造函数和/或一个移动赋值运算符，则该类的合成拷贝构造函数和拷贝赋值运算符会被定义为删除的

+ 如果一个类既有移动构造函数也有拷贝构造函数，编译器使用普通的函数匹配规则来确定使用哪个构造函数

+ 移动右值，拷贝左值

+ 如果一个类没有移动构造函数，函数匹配规则保证该类型的对象会被拷贝，即使我们试图通过调用move来移动它们时也是如此

+ 单一的赋值运算符就是先了拷贝赋值运算符和移动赋值运算符两种功能

+ C++11定义了一种移动迭代器适配器，通过改变给定迭代器的解引用运算符的行为来适配此迭代器。一般而言，一个迭代器的解引用运算符返回一个指向元素的左值，而移动迭代器的解引用运算符生成一个右值引用

+ 通过调用标准库的make_move_iterator函数将一个普通迭代器转换为一个移动迭代器，此函数接受一个迭代器参数，返回一个移动迭代器

+ 可以将一对移动迭代器对传递给算法

+ 标准库不保证那些算法适用移动迭代器，哪些不适用。由于移动一个对象可能销毁原对象，因此只有在确信算法在为一个元素赋值或将其传递给一个用户，定义的函数不再访问它时，才能将移动迭代器传递给算法



#### 13.6.3 右值引用和成员函数

+ 在参数列表后放置一个引用限定符&或&&,分表指出this可以指向一个左值或右值，引用限定符只能用于（非static）成员函数，且必须同时出现在函数的声明和定义中

+ 对于&限定的函数，只能将它用于左值，对于&&限定的函数，也只能用于右值

+ 一个函数可以同时用const和引用限定，在此情况下，引用限定符必须跟随在const限定符之后。

+ 引用限定符可以区分重载版本

+ 如果一个成员函数有引用限定符，则具有相同参数列表的所有版本都必须有引用限定符




