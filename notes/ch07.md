## 第七章 类
  + 类的基本思想是数据抽象和封装。数据抽象是一种依赖于接口和实现分离的编程（以及设计）的技术
### 7.1 定义抽象数据类型
#### 7.1.1 设计Sales_data类
#### 定义改进的Sales_data类
  + 定义在类内部的函数是隐式inline函数
  + 成员函数通过一个名为this的额外的隐式参数来访问调用它的那个对象，编译器负责把调用该函数的类对象的地址传递给隐式形参this
  + 任何对类成员的直接访问都被看作this的隐式引用，任何自定义名为this的参数或变量的行为都是非法的。
  + 紧跟参数列表之后的一个const是修改隐式this指针的类型，默认情况下this类型是指向类类型非常量版本的常量指针，意味着默认情况下，我们不能把this绑定到一个常量对象上，也就是我们不能在一个常量对象上调用普通的成员函数。这里的const表明this是一个指向常量的指针，这样的函数称为常量成员函数
  + 常量对象，常量对象的引用或指针都只能调用常量成员函数
  + 当我们在类的外部定义成员函数时，成员函数的定义必须与它的声明匹配，如果成员函数被声明成常量成员函数，那么它的定义也必须在参数列表后明确指定const属性。类外部定义的成员的名字必须包含它所属的类名

#### 7.1.3 定义类相关的非成员函数
  + 如果函数在概念上属于类但是不定义在类中，则它一般应与类声明（而非定义）在同一个头文件内，在这种方式下，用于使用接口的任何部分都只需要引入一个文件。  

#### 7.1.4 构造函数
  + 构造函数的任务是初始化类对象的数据成员，无论何时只要类的对象被创建，就会执行构造函数。
  + 构造函数的名字和类名相同，构造函数没有返回类型，构造函数不能被声明为const的。当我们创建类的一个const对象时，直到构造函数完成初始化过程，对象才能真正取得其“常量”属性，因此，构造函数在const对象的构造过程中可以向其写值。
  + 如果我们类没有显式地定义构造函数，那么编译器就会为我们隐式地定义一个默认构造函数，编译器创建的构造函数又被称为合成的默认构造函数：
    + 如果存在类内的初始值，用它来初始化成员
    + 否则，默认初始化该成员
  + 有的时候编译器不能为某些类合成默认的构造函数，例如如果类中包含一个其他类型的成员且这个成员的类型没有默认构造函数，那么编译器将无法初始化该成员。
  + 我们有必要定义一个默认构造函数
  + `Sales_data() = default;` 因为该构造函数不接受任何实参，所以是一个默认构造函数，我们希望这个函数的作用完全等同于之前使用的合成默认构造函数，如果我们需要默认的构造函数，可以使用default
  + 如果=default在类的内部，则默认构造函数时内联的，如果在类的外部，则该成员默认情况下不是内联的。
  + `Sales_Data(const std::string &s):bookNo(s){}` 构造函数初始值列表

#### 7.1.5 拷贝、赋值和析构
  + 对象在几种情况下会被拷贝：初始化变量、以值得方式传递或返回一个对象等
  + 编译器生成得版本将对对象的每个成员执行拷贝、赋值和销毁操作。
  + 很多需要动态内存的类能（而且应该）使用vector对象或者string对象管理必要的存储空间，使用vector和string的类能避免分配和释放内存带来的复杂性。

### 7.2 访问控制与封装
  + 定义在public说明符之后的成员在整个程序内可被访问，public成员定义类的接口
  + 定义在private说明符之后的成员可以被类的成员函数访问，但是不能被使用该类的代码访问，private部分封装了（即隐藏了）类的实现细节。
  + 一个类可以包含0个或多个访问说明符，而且对于某个访问说明符能出现多少次也没有严格限定。每个访问说明符指定了接下来的成员的访问级别，其有效范围直到出现下一个访问说明符或者到达类的结尾处为止
  + class和struct都可以定义类，唯一的区别就是struct默认访问为public，class默认访问为private

#### 7.2.1 友元
  + 类可以允许其他类或函数访问它的非公有成员，方法是令其它类或函数成为它的友元。如果要一个函数作为一个类的友元，只要在这个类头文件中增加一条以friend关键字开始的函数声明语句就可以
  + 友元声明只能出现在类定义的内部，但是在类内出现的具体位置不限，友元不是类的成员也不受它所在区域访问控制级别的约束，一般来说，最好在类定义开始或结束前的位置集中声明友元
  + 封装优点：
    + 确保用户代码不会无意间破坏封装对象的状态
    + 被封装的类的具体实现细节可以随时待变，而无须调整用户界别的代码
  + 友元的声明仅仅指定了访问的权限，而非一个通常意义上的函数声明。如果我们希望用户能够调用某个友元函数，那么我们就必须在友元声明之外再专门对函数进行一次声明

### 7.3 类的其他特性
#### 7.3.1 类成员再探
  + 类还可以自定义某种类型再类中的别名，由类定义的类型名字和其他成员一样存在访问限制，可以是public或者private中的一种。用来定义类类型的成员必须先定义后使用
    ```cpp
    class Screen{
    public:
        typedef std::string::size_type pos;
    private:
        pos cursor = 0;
        por height = 0, width = 0;
        std::string contents;
    };
    Screen的用户不应该直到Screen使用了一个string对象来存放它的数据，因此通过把pos定义成public成员可以隐藏Screen实现的细节。  
  + 我们可以在类的内部把inline作为声明的一部分显式地声明成员函数，也能在类外部用inline关键字修饰函数的定义。虽然我们无须在声明和定义的地方同时声明inline，但是这么做是合法的，不过最好只在类外部定义的地方说明inline，这样可以使类更容易理解。inline成员函数也应该与对应的类定义在同一个头文件中
  + 我们希望可以修改类的某个数据成员，即使是在一个const成员函数内。可以通过在变量的声明中加入mutable关键字做到这一点。一个可变数据成员（mutable data member）永远不会是const，即使它是const对象的成员。
  + C++11允许使用类内初始值，类的初始值必须使用=的初始化形式（初始化Screen的数据成员时所用）或者花括号起来的直接初始化形式（初始化screens时所用）  

#### 7.3.2 返回\*this的函数
  + 返回引用的函数是左值的，意味着这些函数返回的是对象本身而非对象的副本。
    ```cpp
    inline Screen &Screen::set(pos r, pos col, char ch){
      contents[r*width+col]=ch;
      return *this;
    }
    ```
    此时可以执行`myScreen.set(1,1,'C).set(1,2,'5).set(2,2,'5);`   
    这里返回引用，所以这些操作能在同一个对象上执行
  + 如果返回的是const对象，则不能紧跟.set()因为const对象不能修改内容，一个const成员函数如果以引用的形式返回\*this，那么它的返回类型将是常量引用
  + 通过区分成员函数是否是const，我们可以对其进行重载
    ```cpp
    Screen &display(std::ostream &os){
      do_display(os);return *this;
    }
    const Screen &display(std::ostream &os)const {
      do_display(os);return *this;
    }
    ```
 
#### 7.3.3类类型
  + 我们可以把类名作为类名的名字使用，从而直接指向类类型，也可以把类名跟在关键字class或struct后面。
  + 我们可以仅声明类而暂时不定义它，在它声明之后定义之前是一个不完全类型
  + 不完全类型只能在非常有限的情景下使用：可以定义指向这种类型的指针或引用，也可以声明（但是不能定义）以不完全类型作为参数或者返回类型的函数
  + 只有当类全部完成后类才算被定义，所以一个类的成员类型不能是该类自己，但是一旦一个类的名字出现后，就被认为是声明过了，因此类允许包含指向它自身类型的引用或指针

#### 7.3.4 友元再探
  + 类可以把其他类定义成友元，也可以把其他类（之前已经定义过的）的成员函数定义成友元。友元函数能定义在类的内部，这样的函数是隐式内联的。  
  + 如果一个类制定了友元类，则友元类的成员函数可以访问此类包括非共有成员在内的所有成员
  + 友元关系不存在传递性，每个类负责控制自己额友元类或友元函数
  + 当把一个成员函数声明成友元时，我们必须明确指出该成员函数属于哪个类
  + 尽管重载函数的名字相同，但它们仍然是不同的函数，因此，如果一个类想把一组重载函数声明成它的友元，它需要对这组函数中的每一个分别声明
  + 类和非成员函数的声明不是必须在它们的友元声明之前，当一个名字第一次出现在一个友元声明中时，我们隐式地假定该名字在当前作用域中是可见的，然而，友元本身不一定真的声明在当前作用域中
  + 甚至就算在类的内部定义该函数，我们也必须在类的外部提供相应的声明从而使得函数可见，即使我们仅仅是用声明友元的类的成员调用该友元函数，它也必须是声明过的。
  + 友元函数的声明作用仅仅是影响访问权限，本身并非普通意义上的声明

### 7.4 类的作用域
#### 7.4.1 名字查找与类的作用域
  + 名字查找，寻找与所用名字最匹配恶的声明的过程：
    + 首先，在名字所在的块中寻找其声明语句，只考虑在名字的使用之前出现的声明
    + 如果没找到，继续查找外层作用域
    + 如果最终没有找到匹配的声明，则程序报错
  + 类的定义分两步：
    + 首先，编译成员的声明
    + 直到类全部可见后才编译函数体
  + 成员函数体直到整个类可见后才会被处理，所以它可以使用类中定义的任何名字
  + 这种两阶段的处理方式只适用于成员函数中使用的名字。声明中使用的名字，包括返回类型或者参数列表中使用的名字，都必须在使用前确保可见。如果某个成员的声明使用了类中尚未出现的名字，则编译器将会在定义该类的作用域中继续查找
  + 内层作用域可以重新定义外层作用域中的名字，即使该名字已经在内层作用域中使用过。然而在类中，如果成员使用了外层作用域中的某个名字，而该名字代表一种类型，则类不能再之后重新定义该名字
  + 类型名的定义通常出现在类的开始处，这样就能确保所有使用该类型的成员都出现在类名的定义之后。

### 7.5 构造函数再探
#### 7.5.1 构造函数初始值列表
  + 如果成员是const或者引用的话，必须将其初始化，当成员属于某种类型且该类没有定义默认构造函数的时候，也必须将这个成员初始化。
  + 随着构造函数体一开始执行，初始化就完成了，我们初始化const或者引用类型的数据成员的唯一机会就是通过构造函数初始值。
  + 构造函数初始值列表只说明用于初始化成员的值，而不限定初始化的具体执行顺序，成员的初始化的顺序与它们在类定义中出现顺序一致。
  + 如果一个构造函数为所有参数都提供了默认实参，则它实际上也定义了默认构造函数。  


    

