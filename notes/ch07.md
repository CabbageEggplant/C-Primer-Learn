## 第七章 类
  + 类的基本思想是数据抽象和封装。数据抽象是一种依赖于接口和实现分离的编程（以及设计）的技术
### 7.1 定义抽象数据类型
#### 7.1.1 设计Sales_data类
#### 定义改进的Sales_data类
  + 定义在类内部的函数是隐式inline函数
  + 成员函数通过一个名为this的额外的隐式参数来访问调用它的那个对象，编译器负责把调用该函数的类对象的地址传递给隐式形参this
  + 任何对类成员的直接访问都被看作this的隐式引用，任何自定义名为this的参数或变量的行为都是非法的。
  + 紧跟参数列表之后的一个const是修改隐式this指针的类型，默认情况下this类型是指向类类型非常量版本的常量指针，意味着默认情况下，我们不能把this绑定到一个常量对象上，也就是我们不能在一个常量对象上调用普通的成员函数。这里的const表明this是一个指向常量的指针，这样的函数称为常量成员函数
  + 常量对象，常量对象的引用或指针都只能调用常量成员函数
  + 当我们在类的外部定义成员函数时，成员函数的定义必须与它的声明匹配，如果成员函数被声明成常量成员函数，那么它的定义也必须在参数列表后明确指定const属性。类外部定义的成员的名字必须包含它所属的类名

#### 7.1.3 定义类相关的非成员函数
  + 如果函数在概念上属于类但是不定义在类中，则它一般应与类声明（而非定义）在同一个头文件内，在这种方式下，用于使用接口的任何部分都只需要引入一个文件。  

#### 7.1.4 构造函数
  + 构造函数的任务是初始化类对象的数据成员，无论何时只要类的对象被创建，就会执行构造函数。
  + 构造函数的名字和类名相同，构造函数没有返回类型，构造函数不能被声明为const的。当我们创建类的一个const对象时，直到构造函数完成初始化过程，对象才能真正取得其“常量”属性，因此，构造函数在const对象的构造过程中可以向其写值。
  + 如果我们类没有显式地定义构造函数，那么编译器就会为我们隐式地定义一个默认构造函数，编译器创建的构造函数又被称为合成的默认构造函数：
    + 如果存在类内的初始值，用它来初始化成员
    + 否则，默认初始化该成员
  + 有的时候编译器不能为某些类合成默认的构造函数，例如如果类中包含一个其他类型的成员且这个成员的类型没有默认构造函数，那么编译器将无法初始化该成员。
  + 我们有必要定义一个默认构造函数
  + `Sales_data() = default;` 因为该构造函数不接受任何实参，所以是一个默认构造函数，我们希望这个函数的作用完全等同于之前使用的合成默认构造函数，如果我们需要默认的构造函数，可以使用default
  + 如果=default在类的内部，则默认构造函数时内联的，如果在类的外部，则该成员默认情况下不是内联的。
  + `Sales_Data(const std::string &s):bookNo(s){}` 构造函数初始值列表

#### 7.1.5 拷贝、赋值和析构
  + 对象在几种情况下会被拷贝：初始化变量、以值得方式传递或返回一个对象等
  + 编译器生成得版本将对对象的每个成员执行拷贝、赋值和销毁操作。
  + 很多需要动态内存的类能（而且应该）使用vector对象或者string对象管理必要的存储空间，使用vector和string的类能避免分配和释放内存带来的复杂性。

### 7.2 访问控制与封装
  + 定义在public说明符之后的成员在整个程序内可被访问，public成员定义类的接口
  + 定义在private说明符之后的成员可以被类的成员函数访问，但是不能被使用该类的代码访问，private部分封装了（即隐藏了）类的实现细节。
  + 一个类可以包含0个或多个访问说明符，而且对于某个访问说明符能出现多少次也没有严格限定。每个访问说明符指定了接下来的成员的访问级别，其有效范围直到出现下一个访问说明符或者到达类的结尾处为止
  + class和struct都可以定义类，唯一的区别就是struct默认访问为public，class默认访问为private

#### 7.2.1 友元
  + 类可以允许其他类或函数访问它的非公有成员，方法是令其它类或函数成为它的友元。如果要一个函数作为一个类的友元，只要在这个类头文件中增加一条以friend关键字开始的函数声明语句就可以
  + 友元声明只能出现在类定义的内部，但是在类内出现的具体位置不限，友元不是类的成员也不受它所在区域访问控制级别的约束，一般来说，最好在类定义开始或结束前的位置集中声明友元
  + 封装优点：
    + 确保用户代码不会无意间破坏封装对象的状态
    + 被封装的类的具体实现细节可以随时待变，而无须调整用户界别的代码
  + 友元的声明仅仅指定了访问的权限，而非一个通常意义上的函数声明。如果我们希望用户能够调用某个友元函数，那么我们就必须在友元声明之外再专门对函数进行一次声明

### 7.3 类的其他特性
#### 7.3.1 类成员再探
  + 类还可以自定义某种类型再类中的别名，由类定义的类型名字和其他成员一样存在访问限制，可以是public或者private中的一种。用来定义类类型的成员必须先定义后使用
    ```cpp
    class Screen{
    public:
        typedef std::string::size_type pos;
    private:
        pos cursor = 0;
        por height = 0, width = 0;
        std::string contents;
    };
    Screen的用户不应该直到Screen使用了一个string对象来存放它的数据，因此通过把pos定义成public成员可以隐藏Screen实现的细节。  
  + 我们可以在类的内部把inline作为声明的一部分显式地声明成员函数，也能在类外部用inline关键字修饰函数的定义。虽然我们无须在声明和定义的地方同时声明inline，但是这么做是合法的，不过最好只在类外部定义的地方说明inline，这样可以使类更容易理解。inline成员函数也应该与对应的类定义在同一个头文件中
  + 我们希望可以修改类的某个数据成员，即使是在一个const成员函数内。可以通过在变量的声明中加入mutable关键字做到这一点。一个可变数据成员（mutable data member）永远不会是const，即使它是const对象的成员。
  + C++11允许使用类内初始值，类的初始值必须使用=的初始化形式（初始化Screen的数据成员时所用）或者花括号起来的直接初始化形式（初始化screens时所用）  

#### 7.3.2 返回\*this的函数
  + 返回引用的函数是左值的，意味着这些函数返回的是对象本身而非对象的副本。
    ```cpp
    inline Screen &Screen::set(pos r, pos col, char ch){
      contents[r*width+col]=ch;
      return *this;
    }
    ```
    此时可以执行`myScreen.set(1,1,'C).set(1,2,'5).set(2,2,'5);`   
    这里返回引用，所以这些操作能在同一个对象上执行
  + 如果返回的是const对象，则不能紧跟.set()因为const对象不能修改内容，一个const成员函数如果以引用的形式返回\*this，那么它的返回类型将是常量引用
  + 通过区分成员函数是否是const，我们可以对其进行重载
    ```cpp
    Screen &display(std::ostream &os){
      do_display(os);return *this;
    }
    const Screen &display(std::ostream &os)const {
      do_display(os);return *this;
    }
    ```
 
#### 7.3.3类类型
  + 我们可以把类名作为类名的名字使用，从而直接指向类类型，也可以把类名跟在关键字class或struct后面。
  + 我们可以仅声明类而暂时不定义它，在它声明之后定义之前是一个不完全类型
  + 不完全类型只能在非常有限的情景下使用：可以定义指向这种类型的指针或引用，也可以声明（但是不能定义）以不完全类型作为参数或者返回类型的函数
  + 只有当类全部完成后类才算被定义，所以一个类的成员类型不能是该类自己，但是一旦一个类的名字出现后，就被认为是声明过了，因此类允许包含指向它自身类型的引用或指针

#### 7.3.4 友元再探
  + 类可以把其他类定义成友元，也可以把其他类（之前已经定义过的）的成员函数定义成友元。友元函数能定义在类的内部，这样的函数是隐式内联的。  
  + 如果一个类制定了友元类，则友元类的成员函数可以访问此类包括非共有成员在内的所有成员
  + 友元关系不存在传递性，每个类负责控制自己额友元类或友元函数
  + 当把一个成员函数声明成友元时，我们必须明确指出该成员函数属于哪个类
  + 尽管重载函数的名字相同，但它们仍然是不同的函数，因此，如果一个类想把一组重载函数声明成它的友元，它需要对这组函数中的每一个分别声明
  + 类和非成员函数的声明不是必须在它们的友元声明之前，当一个名字第一次出现在一个友元声明中时，我们隐式地假定该名字在当前作用域中是可见的，然而，友元本身不一定真的声明在当前作用域中
  + 甚至就算在类的内部定义该函数，我们也必须在类的外部提供相应的声明从而使得函数可见，即使我们仅仅是用声明友元的类的成员调用该友元函数，它也必须是声明过的。
  + 友元函数的声明作用仅仅是影响访问权限，本身并非普通意义上的声明

### 7.4 类的作用域
#### 7.4.1 名字查找与类的作用域
  + 名字查找，寻找与所用名字最匹配恶的声明的过程：
    + 首先，在名字所在的块中寻找其声明语句，只考虑在名字的使用之前出现的声明
    + 如果没找到，继续查找外层作用域
    + 如果最终没有找到匹配的声明，则程序报错
  + 类的定义分两步：
    + 首先，编译成员的声明
    + 直到类全部可见后才编译函数体
  + 成员函数体直到整个类可见后才会被处理，所以它可以使用类中定义的任何名字
  + 这种两阶段的处理方式只适用于成员函数中使用的名字。声明中使用的名字，包括返回类型或者参数列表中使用的名字，都必须在使用前确保可见。如果某个成员的声明使用了类中尚未出现的名字，则编译器将会在定义该类的作用域中继续查找
  + 内层作用域可以重新定义外层作用域中的名字，即使该名字已经在内层作用域中使用过。然而在类中，如果成员使用了外层作用域中的某个名字，而该名字代表一种类型，则类不能再之后重新定义该名字
  + 类型名的定义通常出现在类的开始处，这样就能确保所有使用该类型的成员都出现在类名的定义之后。

### 7.5 构造函数再探
#### 7.5.1 构造函数初始值列表
  + 如果成员是const或者引用的话，必须将其初始化，当成员属于某种类型且该类没有定义默认构造函数的时候，也必须将这个成员初始化。
  + 随着构造函数体一开始执行，初始化就完成了，我们初始化const或者引用类型的数据成员的唯一机会就是通过构造函数初始值。
  + 构造函数初始值列表只说明用于初始化成员的值，而不限定初始化的具体执行顺序，成员的初始化的顺序与它们在类定义中出现顺序一致。
  + 如果一个构造函数为所有参数都提供了默认实参，则它实际上也定义了默认构造函数。  

#### 7.5.2 委托构造函数
  + 一个委托构造函数使用它所属类的其他构造函数执行它自己的初始化过程，或者说它把它自己的一些（或者全部）职责委托给了其他构造函数

#### 7.5.3 默认构造函数的作用
  + 默认初始化在以下情况下发生：
    + 当我们在块作用域内不适用任何初始值定义一个非静态变量
    + 当一个类本身含有类类型的成员且使用合成的默认构造函数时
    + 当类类型的成员没有在构造函数初始值列表中显式地初始化时
  
#### 7.5.4 隐式的类类型转换
  + 如果构造函数只接受了一个实参，则它实际上定义了转换此类类型的隐式转换机制，我们把这种构造函数成为转换构造函数
  + 编译器只会自动地执行异步类型转换
  + 在要求隐式转换上下文中，没我呢看可以通过将构造函数声明为explicit加以阻止
  + 关键字explicit只对一个实参地构造函数有效，只能在类内声明构造函数时使用explicit关键字，在类外部定义时不应该重复。
  + 发生隐式转换地一种情况是当我们执行拷贝形式地初始化时

#### 7.5.5 聚合类
  + 聚合类使得用户可以直接访问其成员，并且具有特殊的初始化语法。聚合类满足条件：
    + 所有成员都是public
    + 没有定义任何构造函数
    + 没有类内初始值
    + 没有基类，也没有virtual函数
  + 可以使用一个花括号括起来的成员初始值列表，并用初始化聚合类的数据成员，`Data vail = {0,"Anna"};`,初始值的顺序必须与声明的顺序一致。如果初始值列表中的元素的个数少于类的成员数量，则靠后的成员被值初始化。初始值列表的元素个数绝对不能超过类的成员数量
  + 显式地初始化类的对象的成员存在三个明显的缺点：
    + 要求类的所有成员都是public的
    + 将正确初始化每个对象的每个成员的众人交给了类的用户（而非类的作者）。而用户的操作很可能是不准确的
    + 添加或删除一个成员之后，所有初始化语句都需要更新

#### 7.5.6 字面值常量类
  + 字面值类型的类可能含有constexpr函数成员，这样的成员必须符合constexpr函数的所有要求，它们是隐式的。数据成员都是字面值类型的聚合类是字面值常量类，如果一个类不是聚合类，但是符合下面的要求，则也是一个字面值常量类：
    + 数据成员都必须是字面值类型
    + 类必须至少含有一个constexpr构造函数
    + 如果一个数据成员含有类内初始值，则内置类型成员的初始值必须是一条常量表达式；或者如果成员属于某种类类型，则初始值必须使用成员自己的constexpr构造函数
    + 类必须使用析构函数的默认含义，该成员负责销毁类的对象
  + 尽管构造函数不能是const,但是字面值常量类的构造函数可以是constexpr，一个字面值常量类必须至少提供一个constexpr构造函数
  + constexpr构造函数体一般来说应该是空的，必须初始化所有数据成员，初始值或者使用constexpr构造函数，或者是一条常量表达式。
  + constexpr构造函数用于生成constexpr对象以及constexpr函数的参数或返回类型



    

