## 第七章 类
  + 类的基本思想是数据抽象和封装。数据抽象是一种依赖于接口和实现分离的编程（以及设计）的技术
### 7.1 定义抽象数据类型
#### 7.1.1 设计Sales_data类
#### 定义改进的Sales_data类
  + 定义在类内部的函数是隐式inline函数
  + 成员函数通过一个名为this的额外的隐式参数来访问调用它的那个对象，编译器负责把调用该函数的类对象的地址传递给隐式形参this
  + 任何对类成员的直接访问都被看作this的隐式引用，任何自定义名为this的参数或变量的行为都是非法的。
  + 紧跟参数列表之后的一个const是修改隐式this指针的类型，默认情况下this类型是指向类类型非常量版本的常量指针，意味着默认情况下，我们不能把this绑定到一个常量对象上，也就是我们不能在一个常量对象上调用普通的成员函数。这里的const表明this是一个指向常量的指针，这样的函数称为常量成员函数
  + 常量对象，常量对象的引用或指针都只能调用常量成员函数
  + 当我们在类的外部定义成员函数时，成员函数的定义必须与它的声明匹配，如果成员函数被声明成常量成员函数，那么它的定义也必须在参数列表后明确指定const属性。类外部定义的成员的名字必须包含它所属的类名

#### 7.1.3 定义类相关的非成员函数
  + 如果函数在概念上属于类但是不定义在类中，则它一般应与类声明（而非定义）在同一个头文件内，在这种方式下，用于使用接口的任何部分都只需要引入一个文件。  

#### 7.1.4 构造函数
  + 构造函数的任务是初始化类对象的数据成员，无论何时只要类的对象被创建，就会执行构造函数。
  + 构造函数的名字和类名相同，构造函数没有返回类型，构造函数不能被声明为const的。当我们创建类的一个const对象时，直到构造函数完成初始化过程，对象才能真正取得其“常量”属性，因此，构造函数在const对象的构造过程中可以向其写值。
  + 如果我们类没有显式地定义构造函数，那么编译器就会为我们隐式地定义一个默认构造函数，编译器创建的构造函数又被称为合成的默认构造函数：
    + 如果存在类内的初始值，用它来初始化成员
    + 否则，默认初始化该成员
  + 有的时候编译器不能为某些类合成默认的构造函数，例如如果类中包含一个其他类型的成员且这个成员的类型没有默认构造函数，那么编译器将无法初始化该成员。
  + 我们有必要定义一个默认构造函数
  + `Sales_data() = default;` 因为该构造函数不接受任何实参，所以是一个默认构造函数，我们希望这个函数的作用完全等同于之前使用的合成默认构造函数，如果我们需要默认的构造函数，可以使用default
  + 如果=default在类的内部，则默认构造函数时内联的，如果在类的外部，则该成员默认情况下不是内联的。
  + `Sales_Data(const std::string &s):bookNo(s){}` 构造函数初始值列表

#### 7.1.5 拷贝、赋值和析构
  + 对象在几种情况下会被拷贝：初始化变量、以值得方式传递或返回一个对象等
  + 编译器生成得版本将对对象的每个成员执行拷贝、赋值和销毁操作。
  + 很多需要动态内存的类能（而且应该）使用vector对象或者string对象管理必要的存储空间，使用vector和string的类能避免分配和释放内存带来的复杂性。

### 7.2 访问控制与封装
  + 定义在public说明符之后的成员在整个程序内可被访问，public成员定义类的接口
  + 定义在private说明符之后的成员可以被类的成员函数访问，但是不能被使用该类的代码访问，private部分封装了（即隐藏了）类的实现细节。
  + 一个类可以包含0个或多个访问说明符，而且对于某个访问说明符能出现多少次也没有严格限定。每个访问说明符指定了接下来的成员的访问级别，其有效范围直到出现下一个访问说明符或者到达类的结尾处为止
  + class和struct都可以定义类，唯一的区别就是struct默认访问为public，class默认访问为private

#### 7.2.1 友元
  + 类可以允许其他类或函数访问它的非公有成员，方法是令其它类或函数成为它的友元。如果要一个函数作为一个类的友元，只要在这个类头文件中增加一条以friend关键字开始的函数声明语句就可以
  + 友元声明只能出现在类定义的内部，但是在类内出现的具体位置不限，友元不是类的成员也不受它所在区域访问控制级别的约束，一般来说，最好在类定义开始或结束前的位置集中声明友元
  + 封装优点：
    + 确保用户代码不会无意间破坏封装对象的状态
    + 被封装的类的具体实现细节可以随时待变，而无须调整用户界别的代码
  + 友元的声明仅仅指定了访问的权限，而非一个通常意义上的函数声明。如果我们希望用户能够调用某个友元函数，那么我们就必须在友元声明之外再专门对函数进行一次声明

### 7.3 类的其他特性
#### 7.3.1 类成员再探
  + 类还可以自定义某种类型再类中的别名，由类定义的类型名字和其他成员一样存在访问限制，可以是public或者private中的一种。用来定义类类型的成员必须先定义后使用
    ```cpp
    class Screen{
    public:
        typedef std::string::size_type pos;
    private:
        pos cursor = 0;
        por height = 0, width = 0;
        std::string contents;
    };
    Screen的用户不应该直到Screen使用了一个string对象来存放它的数据，因此通过把pos定义成public成员可以隐藏Screen实现的细节。  
  + 我们可以在类的内部把inline作为声明的一部分显式地声明成员函数，也能在类外部用inline关键字修饰函数的定义。虽然我们无须在声明和定义的地方同时声明inline，但是这么做是合法的，不过最好只在类外部定义的地方说明inline，这样可以使类更容易理解。inline成员函数也应该与对应的类定义在同一个头文件中
  + 我们希望可以修改类的某个数据成员，即使是在一个const成员函数内。可以通过在变量的声明中加入mutable关键字做到这一点。一个可变数据成员（mutable data member）永远不会是const，即使它是const对象的成员。
  + C++11允许使用类内初始值，类的初始值必须使用=的初始化形式（初始化Screen的数据成员时所用）或者花括号起来的直接初始化形式（初始化screens时所用）  

#### 7.3.2 返回\*this的函数
  + 返回引用的函数是左值的，意味着这些函数返回的是对象本身而非对象的副本。
    ```cpp
    inline Screen &Screen::set(pos r, pos col, char ch){
      contents[r*width+col]=ch;
      return *this;
    }
    ```
    此时可以执行`myScreen.set(1,1,'C).set(1,2,'5).set(2,2,'5);`   
    这里返回引用，所以这些操作能在同一个对象上执行
  + 如果返回的是const对象，则不能紧跟.set()因为const对象不能修改内容，一个const成员函数如果以引用的形式返回\*this，那么它的返回类型将是常量引用
  + 通过区分成员函数是否是const，我们可以对其进行重载
    ```cpp
    Screen &display(std::ostream &os){
      do_display(os);return *this;
    }
    const Screen &display(std::ostream &os)const {
      do_display(os);return *this;
    }
    ```
 
    
    

