## 第七章 类
  + 类的基本思想是数据抽象和封装。数据抽象是一种依赖于接口和实现分离的编程（以及设计）的技术
### 7.1 定义抽象数据类型
#### 7.1.1 设计Sales_data类
#### 定义改进的Sales_data类
  + 定义在类内部的函数是隐式inline函数
  + 成员函数通过一个名为this的额外的隐式参数来访问调用它的那个对象，编译器负责把调用该函数的类对象的地址传递给隐式形参this
  + 任何对类成员的直接访问都被看作this的隐式引用，任何自定义名为this的参数或变量的行为都是非法的。
  + 紧跟参数列表之后的一个const是修改隐式this指针的类型，默认情况下this类型是指向类类型非常量版本的常量指针，意味着默认情况下，我们不能把this绑定到一个常量对象上，也就是我们不能在一个常量对象上调用普通的成员函数。这里的const表明this是一个指向常量的指针，这样的函数称为常量成员函数
  + 常量对象，常量对象的引用或指针都只能调用常量成员函数
  + 当我们在类的外部定义成员函数时，成员函数的定义必须与它的声明匹配，如果成员函数被声明成常量成员函数，那么它的定义也必须在参数列表后明确指定const属性。类外部定义的成员的名字必须包含它所属的类名

#### 7.1.3 定义类相关的非成员函数
  + 如果函数在概念上属于类但是不定义在类中，则它一般应与类声明（而非定义）在同一个头文件内，在这种方式下，用于使用接口的任何部分都只需要引入一个文件。  

#### 7.1.4 构造函数
  + 构造函数的任务是初始化类对象的数据成员，无论何时只要类的对象被创建，就会执行构造函数。
  + 构造函数的名字和类名相同，构造函数没有返回类型，构造函数不能被声明为const的。当我们创建类的一个const对象时，直到构造函数完成初始化过程，对象才能真正取得其“常量”属性，因此，构造函数在const对象的构造过程中可以向其写值。
  + 如果我们类没有显式地定义构造函数，那么编译器就会为我们隐式地定义一个默认构造函数，编译器创建的构造函数又被称为合成的默认构造函数：
    + 如果存在类内的初始值，用它来初始化成员
    + 否则，默认初始化该成员
  + 有的时候编译器不能为某些类合成默认的构造函数，例如如果类中包含一个其他类型的成员且这个成员的类型没有默认构造函数，那么编译器将无法初始化该成员。
  + 我们有必要定义一个默认构造函数
  + `Sales_data() = default;` 因为该构造函数不接受任何实参，所以是一个默认构造函数，我们希望这个函数的作用完全等同于之前使用的合成默认构造函数，如果我们需要默认的构造函数，可以使用default
  + 如果=default在类的内部，则默认构造函数时内联的，如果在类的外部，则该成员默认情况下不是内联的。
  + `Sales_Data(const std::string &s):bookNo(s){}` 构造函数初始值列表

#### 7.1.5 拷贝、赋值和析构
  + 对象在几种情况下会被拷贝：初始化变量、以值得方式传递或返回一个对象等
  + 编译器生成得版本将对对象的每个成员执行拷贝、赋值和销毁操作。
  + 很多需要动态内存的类能（而且应该）使用vector对象或者string对象管理必要的存储空间，使用vector和string的类能避免分配和释放内存带来的复杂性。

### 7.2 访问控制与封装
  + 定义在public说明符之后的成员在整个程序内可被访问，public成员定义类的接口
  + 定义在private说明符之后的成员可以被类的成员函数访问，但是不能被使用该类的代码访问，private部分封装了（即隐藏了）类的实现细节。
  + 一个类可以包含0个或多个访问说明符，而且对于某个访问说明符能出现多少次也没有严格限定。每个访问说明符指定了接下来的成员的访问级别，其有效范围直到出现下一个访问说明符或者到达类的结尾处为止
  + class和struct都可以定义类，唯一的区别就是struct默认访问为public，class默认访问为private

