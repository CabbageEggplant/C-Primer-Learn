## 第七章 类
  + 类的基本思想是数据抽象和封装。数据抽象是一种依赖于接口和实现分离的编程（以及设计）的技术
### 7.1 定义抽象数据类型
#### 7.1.1 设计Sales_data类
#### 定义改进的Sales_data类
  + 定义在类内部的函数是隐式inline函数
  + 成员函数通过一个名为this的额外的隐式参数来访问调用它的那个对象，编译器负责把调用该函数的类对象的地址传递给隐式形参this
  + 任何对类成员的直接访问都被看作this的隐式引用，任何自定义名为this的参数或变量的行为都是非法的。
  + 紧跟参数列表之后的一个const是修改隐式this指针的类型，默认情况下this类型是指向类类型非常量版本的常量指针，意味着默认情况下，我们不能把this绑定到一个常量对象上，也就是我们不能在一个常量对象上调用普通的成员函数。这里的const表明this是一个指向常量的指针，这样的函数称为常量成员函数
  + 常量对象，常量对象的引用或指针都只能调用常量成员函数
  + 当我们在类的外部定义成员函数时，成员函数的定义必须与它的声明匹配，如果成员函数被声明成常量成员函数，那么它的定义也必须在参数列表后明确指定const属性。类外部定义的成员的名字必须包含它所属的类名

#### 7.1.3 定义类相关的非成员函数
  + 如果函数在概念上属于类但是不定义在类中，则它一般应与类声明（而非定义）在同一个头文件内，在这种方式下，用于使用接口的任何部分都只需要引入一个文件。  

#### 7.1.4 构造函数
  + 构造函数的任务是初始化类对象的数据成员，无论何时只要类的对象被创建，就会执行构造函数。
  + 构造函数的名字和类名相同，构造函数没有返回类型，构造函数不能被声明为const的。当我们创建类的一个const对象时，直到构造函数完成初始化过程，对象才能真正取得其“常量”属性，因此，构造函数在const对象的构造过程中可以向其写值。
  + 如果我们类没有显式地定义构造函数，那么编译器就会为我们隐式地定义一个默认构造函数，编译器创建的构造函数又被称为合成的默认构造函数：
    + 如果存在类内的初始值，用它来初始化成员
    + 否则，默认初始化该成员
  + 有的时候编译器不能为某些类合成默认的构造函数，例如如果类中包含一个其他类型的成员且这个成员的类型没有默认构造函数，那么编译器将无法初始化该成员。
  + 我们有必要定义一个默认构造函数
  + `Sales_data() = default;` 因为该构造函数不接受任何实参，所以是一个默认构造函数，我们希望这个函数的作用完全等同于之前使用的合成默认构造函数，如果我们需要默认的构造函数，可以使用default
  + 如果=default在类的内部，则默认构造函数时内联的，如果在类的外部，则该成员默认情况下不是内联的。
  + `Sales_Data(const std::string &s):bookNo(s){}` 构造函数初始值列表

