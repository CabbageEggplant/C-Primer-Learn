## 第五章 语句
### 5.1 简单语句
  + 复合语句是指用花括号括起来的（可能为空）语句和声明的序列
### 5.2 语句作用域
### 5.3 条件语句
#### 5.3.1 if语句
  + if语句有两种形式
    + ```cpp
      if(condition)
          statement
      ```
    + ```cpp
      if(condition)
          statement1
      else
          statemebt2
      ```
  + 悬垂else,if的个数多余else的个数，C++规定else与它最近的尚未匹配的if匹配，从而消除程序的二义性。使用花括号控制执行路径

#### 5.3.2 switch语句
  + switch语句首先对括号里的表达式求值，表达式的值转换成整数类型，然后与每个case的值进行比较。如果表达式和某个case标签的值匹配成功，程序从该标签之后的第一条语句开始执行，知道达到了switch的结尾或者遇到一条break语句为止。  
  + case标签：case关键字和它对应的值。case标签必须式整型常量表达式，任何两个case标签的值不能相同，否则就会引发编译错误
  + defaule标签，如果没有任何一个case标签能够匹配得上switch表达式的值，程序将执行紧跟在defaule标签后面的语句
  + switch内部的变量定义  
    ```cpp
      case true:
        string file_name;  //错误，控制流绕过一个隐式初始化的变量
        int ival = 0; //错误，控制流绕过一个显式初始化的变量
        int jval; //正确，因为jval没有初始化
        break;
      case false:
        jval = 10; //jval 在作用域内
        break;
    ```
    在case true中定义的变量在case false中也能使用，但是如果程序直接跳过true执行false,就会出现没有初始化的异常，因此编译的时候就会报错。C++不允许跨过变量的初始化语句直接跳转到该变量作用域内的另一个位置。可以给case true加{}这样就更改了变量的作用域，就不出报这个编译错误了
 
### 5.4 迭代语句
#### 5.4.1 while语句
   + 定义在while条件部分或者while循环体内的变量每次迭代都经历从创建到销毁的过程

#### 5.4.2 传统的for语句
  + for中的初始化可以定义多个对象，但是只能有一条声明语句，因此所有变量的基础类型必须相同
  + 省略condition的效果等价于在条件部分写了一个true

#### 5.4.3 范围for语句
  + ```cpp
    for(declaration:expression)
        statement
    ```
    其中expression必须是一个序列，比如用花括号括起来的初始值列表或者其他对象，其共同特点是拥有能返回迭代器的begin和end成员，如果需要对序列中的内容执行写操作，循环变量必须声明成引用类型。
  + 范围for语句的定义来源于与之等价的传统for语句`for(auto beg=v.begin(),end=v.end();beg!=end;++beg)`

#### 5.4.4 do while语句
  + do while和while非常相似，唯一的区别就是do while语句限制性循环体后再检查条件。
  + 不允许在条件部分定义变量，因为do while先执行循环体再执行条件部分。
  + 
        
### 5.5跳转语句
#### 5.5.1break语句
  + break语句负责终止离它最近地while、do while、for或switch语句，并从这些语句之后的第一条语句开始继续执行。  

#### 5.5.2continue语句
  + continue语句终止最近的循环中的当前迭代并立即开始下一次迭代。

#### 5.5.3goto语句
  + `goto label`，其中label是用于标识一条语句的标识符，带标签语句是一种特殊的语句，在它之前有一个标识符以及一个冒号。标签符号独立于变量或其他提示符的名字，因此标签标识符可以和程序中其他实体的标识符使用同一个名字而不会相互干扰。
  + 和switch类似，goto语句也不能将程序的控制权从变量的作用域之外转移到作用域之内。  
  + ```cpp
    begin: int ix = 10;
    goto begin;
    ```
    goto语句执行后会销毁sz，然后重新定义初始化
  
### 5.6 try语句块和异常处理
  + 异常是指存在与运行时地反常行为，典型地异常行为包括失去数据库地连接以及遇到意外输入等。
  + 异常处理机制为程序中异常检测和异常处理这两部分地协作提供支持： 
    + throw表达式，异常检测部分使用throw表达式来表示它遇到了无法处理的问题，我们说throw引发了异常
    + try语句块，异常处理部分使用try语句处理异常。trye语句块以关键字tr开始，并以一个或多个catch子句结束。try语句块中代码抛出地异常通常会被某个catch字句处理。因为catch字句处理异常，所以它们也被称作异常处理代码。
    + 一套异常类，用于在throw表达式相关地catch字句之间传递异常地具体信息。
  
#### 5.6.1 throw表达式
  + throw表达式包含关键字throw和紧随其后地一个表达式，其中表达式的类型就是抛出的异常类型。throw表达式后面通常紧跟一个分号，从而构成一条表达式语句。  
  + 抛出异常将终止当前的函数，并把控制权转移给能处理该异常的代码。

#### 5.6.2 try语句块
  + catch子句包含三个部分：关键字catch、括号内一个（可能未命名的）对象的声明（异常声明）、一个块。 catch子句一旦完成，程序将跳转到try语句块最后一个catch子句之后的那条语句继续执行。
  + try语句块内声明的变量在块外部无法访问，特别是在catch子句中也无法访问。  
  + 每个标准异常库都定义了名为what的成员函数，这些函数没有参数，返回值是C风格字符串（即const char \*）。其中,runtime_error的what成员返回的是初始化的一个具体对象时所用的string对象的副本。
  + 寻找处理代码的过程与函数调用链刚好相反。当异常被抛出时，首先搜索抛出该异常的函数。如果没找到匹配的cach子句，终止该函数，并在调用该函数的函数中继续寻找它的函数。以此类推，沿着程序的执行路径逐层回退，直到找到适当类型的catch子句为止。如果最终没有找到任何匹配的catch子句，程序转到名为terminate的标准库函数，该函数的行为与系统有关，一般执行该函数将导致程序非正常退出。

#### 5.6.3 标准异常
  + C++标准库中定义了一组类，用于报告标准库函数遇到的问题，这些异常类也可以在用户编写的程序中使用，分别定义在四个头文件中：
    + exception头文件中定义了最通用的异常类exception,只报告异常的发生，不提供任何额外的信息。
    + stdexcept头文件定义了集中常用的异常类
    + new头文件中定义了bad_alloc异常类型。
    + type_info头文件定义了bad_cast异常类型
  + stdexcept定义的异常类：
    | 类 | 含义 |
    | :----- | :----- |
    | exception | 最常见的问题 |
    | runtime_error | 只有在运行时才能检测出的问题 |
    | range_error | 运行时错误：生成的结果超出了有意义的值域范围 |
    | overflow_error | 运行时错误：计算上溢 |
    | underflow_error | 运行时错误：计算下溢 | 
    | logic_error | 程序逻辑错误 |
    | domain_error | 逻辑错误，参数对应的结果不存在 |
    | invalid_error | 逻辑错误：无效参数 |
    | length_error | 逻辑错误：试图创建一个超出该类型最大长度的对象 |
    | out_of_range | 逻辑错误：使用一个超出有效范围的值 | 
  





























