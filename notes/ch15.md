## 第十五章 面向对象程序设计

### 15.1 OOP:概述

+ 面向对象程序设计的核心思想是数据抽象、继承和动态绑定。使用数据抽象可以将类的接口与实现分离；使用继承可以定义相似的类型并对其相似关系建模；使用动态绑定可以在一定程度上忽略相似类型的区别，而以统一的方式使用它们的对象

+ 通过继承联系在一起的类构成一种层次关系，通常在层次关系的根部有一个基类，其他类则直接或间接地从基类继承而来，这些继承得到的类称为派生类。基类负责定义在层次关系中所有类共同拥有的成员，而每个派生类定义各自特有的成员

+ 虚函数：基类希望它的派生类各自定义适合自身的版本

+ 派生类必须通过使用类派生列表明确指出是从那个（哪些）基类继承而来，类派生列表形式：首先是一个冒号，后面紧跟以逗号分隔的基类列表，其中每个基类前面可以有访问说明符

+ 派生类必须在其内部对所有重新定义的虚函数进行声明

+ 通过使用动态绑定，可以用同一段代码分别处理基类和派生类的对象

+ 函数的运行版本由实参决定，即在运行时选择函数版本，所以动态绑定又被称为运行时绑定

### 15.2 定义基类和派生类

#### 15.2.1 定义基类

+ 基类通常都应该定义一个虚析构函数，即使该函数不执行任何实际操作也是如此

+ 基类需要将两种成员函数区分开：
  
  + 基类希望其派生类覆盖的函数，通常定义为虚函数
  
  + 基类希望派生类直接继承而不要改变的函数

+ 任何构造函数之外的非静态函数都可以是虚函数

+ 如果基类将一个函数声明为虚函数，则该函数在派生类中隐式地也是虚函数

+ 成员函数如果没有被声明为虚函数，则其解析过程发生在编译时而非运行时

#### 15.2.2 定义派生类

+ 派生类必须通过类派生列表明确指出是从哪个（哪些）基类继承而来的。类派生列表形式：首先是一个冒号，后面紧跟以逗号分隔的基类列表，其中每个基类前面可以有以下三种访问说明符中的一个：public,private,protected

+ 派生类必须将其继承而来的成员函数中需要覆盖的那些重新声明

+ 可以将公有派生类型的对象绑定到基类的引用或指针上

+ 派生类经常（但不总是）覆盖它继承的虚函数。如果派生类没有覆盖其基类中的某个虚函数，则该虚函数的行为类似于其他的普通成员，派生类会直接而继承其在基类中的版本

+ C++11允许派生类显式地注明它使用某个成员函数覆盖它继承的虚函数。具体做法是在形参列表后面、或者在const成员函数的const关键字后面、或者在引用成员函数的引用限定符后面添加一个关键字override

+ 一个派生类对象包含多个组成部分：
  
  + 含有派生类自己定义的（非静态）成员的子对象
  
  + 与该派生类继承的基类对应的子对象，如果有多个基类，则会有多个这样的子对象

+ C++标准没有明确规定派生类的对象在内存中如何分布

+ 在一个对象中，继承自基类的部分和派生类自定义的部分不一定是连续存储的

+ 因为在派生了对象中含有与其基类对应的组成部分，所以我们能把派生类的对象当成基类对象来使用，而且可以将基类的指针或引用绑定到派生类对象的基类部分上，称作派生类到基类的类型转换

+ 在派生类对象中含有与其基类对应的组成部分，这一事实是继承的关键所在

+ 尽管在派生类对象中含有从基类继承而来的成员，但是派生类并不能直接初始化这部分成员，需要使用基类的构造函数初始化。每个类控制其自己的成员初始化过程

+ 除非特别指出，否则派生类对象的基类部分会像数据成员一样执行默认初始化，如果想使用其他的基类构造函数，需要以类名加圆括号的实参俩表的形式为构造函数提供初始值

+ 首先初始化基类的部分，然后按照声明的顺序依次初始化派生类的成员

+ 需要遵循类的接口，每个类负责定义各自的接口，要想与类的对象交互必须使用该类的接口，即使这个对象是派生类的基类部分也是如此

+ 如果基类定义了一个静态成员，则在整个继承体系中只存在该成员的唯一定义，不论从基类中派生出多少个派生类，对于每个静态成员来说都只有唯一的实例

+ 静态成员遵循通用的访问控制规则

+ 如果想要将某个类用作基类，则该类必须已经定义而非仅仅声明

+ C++11新标准提供了一种防止继承发生的方法，即在类名后跟一个关键字final

#### 15.2.3 类型转换与继承

+ 可以讲基类的指针或引用绑定到派生类对象上有一层极为重要的含义：当使用基类的引用（或指针）时，实际上我们并不清楚该引用（或指针）所绑定对象的真实类型

+ 当我们使用存在继承关系的类型时，必须将一个变量或其他表达式的静态类型与该表达式对象的动态类型区分开来，表达式的静态类型在编译时总是已知的，它是变量声明时的类型或表达式生成的类型；动态类型时变量或表达式表示的内存中的对象的类型，动态类型直到运行时才可知

+ 类类型指针的静态类型就是这个类类型，动态类型是实际绑定的对象的类型

+ 如果表达式既不是引用也不是指针，则它的动态类型永远与静态类型一致

+ 不存在从基类向派生类的隐式类型转换，一个基类的对象既可以以独立的形式存在，也可以作为派生类对象的一部分存在

+ 即使一个基类指针或引用绑定在一个派生类对象上，我们也不能执行从基类向派生类的转换

+ 当我们用一个派生类对象为一个基类对象初始化或复制时，只有该派生类对象中的基类部分会被拷贝、移动或复制，它的派生类部分将被忽略掉

### 15.3 虚函数

+ 必须为每一个虚函数提供一个定义，而不管它是否被用到了，这是因为连编译器也无法确定到底会使用哪个虚函数

+ 对非虚函数的调用在编译时进行绑定，通过对象进行的函数（虚函数或非虚函数）调用也在编译时绑定

+ 当我们在派生类中覆盖了某个虚函数时，可以再一次使用virtual关键字指出该函数的性质，然而这是非必须的，因为一旦某个函数被声明成虚函数，则在所有派生类中都是虚函数

+ 一个派生类的函数如果覆盖了某个继承而来的虚函数，则它的形参类型必须与被它覆盖的基类函数完全一致

+ 派生类中虚函数的返回类型也必须与基类函数匹配（当类的虚函数返回类型是类本身的指针或引用时例外），即如果D是由B派生得到，则基类的虚函数可以返回B*而派生类的对应函数可以返回D*，不过需要从D到B的类型转换是可以访问的

+ 如果使用override标记了某个函数，但该函数并没有覆盖已存在的虚函数，此时编译器将报错

+ 如果将函数定义成final，则之后任何尝试覆盖该函数的操作都将引发错误

+ 如果通过基类的引用或指针调用函数，则使用基类中定义的默认实参，即使实际运行的是派生类中的函数版本也是如此

+ 如果虚函数使用默认实参，则基类和派生类中定义的默认实参最好一致

+ 在某些情况下，希望对虚函数的调用不要进行动态绑定，而是强迫其执行虚函数的某个特定版本，可以使用类作用域运算符

+ 如果一个派生类虚函数需要调用它的基类版本，但是没有使用作用域运算符，则在运行时该调用被解析为对派生类版本自身的调用，从而导致无限递归

### 15.4 抽象基类

+ 通过在函数体的位置（声明语句的分号前）加上=0就可以将一个虚函数说明为纯虚函数，=0只能出现在类内部的虚函数声明语句处，纯虚函数无须定义

+ 也可以为纯虚函数提供定义，不过函数体必须定义在类的外部

+ 含有（或未经覆盖直接继承）的纯虚函数的类是抽象基类，抽象基类负责定义接口，不能直接创建一个抽象基类的对象

### 15.5 访问控制与继承

+ protected说明符可以看作是public和private中和后的产物：
  
  + 和私有成员类似，私有保护成员对于类的用户是不可访问的
  
  + 和公有成员类似，受保护的成员对于派生类和友元来说是可以访问的
  
  + 派生类的成员或友元只能通过派生类对象来访问基类的受保护成员，派生类对于一个基类对象中受保护和成员没有任何访问特权

+ 派生类的成员和友元只能访问派生类对象中的基类部分的受保护成员，对于普通的基类对象中的成员不具有特殊的访问权限

+ 某个类对于继承而来的成员的访问权限收到两个因素影响：
  
  + 基类中该成员的访问说明符
  
  + 在派生类的派生列表中的访问说明符

+ 公有继承：基类的公有成员和保护成员作为派生类的成员时，都保持原先的状态。派生类的成员函数可以访问基类的公有成员和保护成员，派生类的对象只可以访问基类的公有成员

+ 保护继承：基类的公有成员和保护成员都称为派生类的保护成员。派生类的成员函数可以访问基类的公有成员和保护成员，派生类的对象不可以访问

+ 私有继承：基类的公有成员和保护成员都成为派生类的私有成员。派生类的成员函数可以访问基类的公有成员和保护成员，派生类对象不可以访问

+ 派生类访问说明符对于派生类的成员及友元能否访问其直接基类的成员没什么影响，对基类成员的访问权限只与基类的访问说明符有关

+ 派生类向基类转换的可访问性，假设B是D的基类：
  
  + 只有当D公有继承B时，用户代码才能使用派生类向基类的转换；如果是私有继承和保护继承，则用户代码不能转换
  
  + 不论D以什么方式继承B,D的成员函数和友元都能使用派生类向基类的转换
  
  + 如果是公有继承和保护继承，则D的派生类的成员和友元可以使用D向B的转换；否则不能

+ 对于代码中的某个给定结点，如果基类的公有成员是可以访问的，则派生类向基类的转换也是可以访问的，反之不行

+ 友元关系不能传递同样也不能继承，基类的友元在访问派生类成员时不具有特殊性，派生类的友元也不能随意访问基类的成员

+ 需要改变派生类继承的某个名字的访问级别时，通常使用using声明，using声明中名字的访问权限由该using声明语句之前的访问说明符来决定，派生类只能为那些它可以访问的名字提供using声明

### 15.6 继承中的类作用域

+ 派生类的作用域嵌套在其基类的作用域之内，如果一个名字在派生类的作用域内无法正确解析，则编译器将继续在外层的基类作用域中寻找改名字的含义

+ 一个对象、引用或指针的静态类型决定了该对象的哪些成员是可见的

+ 定义在内层作用域（即派生类）的名字将隐藏定义在外层作用域（即基类）的名字

+ 可以通过作用域运算符来使用一个被隐藏的基类成员

+ 假定调用p->mem()或者obj.mem()，则依次执行下述步骤：
  
  + 首先确定p(或obj)的静态类型。因为调用的是一个成员，所以这个类型必须是类类型
  
  + 在p(或obj)的静态类型对应的类中查找mem.如果找不到，则依次在直接基类中不断查找直至到达继承链的顶端。如果找遍了该类及其基类仍然找不到，则编译器报错
  
  + 一旦找到了mem,就进行常规的类型检查已确认对于当前找到的mem，本次调用是否合法
  
  + 假设调用合法，则编译器将根据调用的是否是虚函数而产生不同的代码
    
    + 如果mem是虚函数，且是通过引用或指针进行的调用，则编译器产生的代码将在运行时确定到底运行该虚函数的哪个版本，依据是对象的动态类型
    
    + 如果mem不是虚函数或者是通过对象进行的调用，则编译器将产生一个常规函数调用

+ 如果派生类的成员与基类的某个成员同名，则派生类将在其作用域内隐藏该基类成员，即使派生类成员和基类成员的形参列表不一致，基类成员也依然会被隐藏掉

+ 成员函数无论是否是虚函数都可以被重载，派生类可以覆盖重载函数的0个或多个实例。如果派生类希望所有重载版本对于它来说都是可见的，那么就需要覆盖所有的版本，或者一个也不覆盖

+ 有时一个类仅需覆盖重载集合中的一些而非全部函数，此时，如果不得不覆盖基类中的每一个版本，则操作会及其繁琐。解决办法是为重载的成员提供一条using声明语句，这样就无需覆盖基类中的每一个重载版本。using声明语句指定一个名字而不指定形参列表，所以一条基类成员函数的using声明就可以把该函数的所有重载实例添加到派生类的作用域中，此时，派生类只需要定义其特有的函数就可以了，而无需为继承而来的其他函数重新定义。



### 15.7 构造函数与拷贝控制

#### 15.7.1 虚析构函数

+ 继承关系对基类拷贝控制最直接的影响是基类通常应该定义一个一个虚析构函数，这样就可以动态分配继承体系中的对象了

+ 只要基类的析构函数是虚函数，就能确保当我们delete基类指针时将运行正确的析构函数版本



### 15.7.2 合成拷贝控制与继承

+ 某些定义基类的方式可能导致有的派生类成员称为被删除的函数：
  
  + 如果基类中的默认构造函数、拷贝构造函数、拷贝赋值运算符或析构函数时被删除的函数或者不可访问，则派生类中对应的成员将是被删除的，原因是编译器不能使用基类成员来执行派生类对象基类部分的构造、赋值或销毁操作
  
  + 如果在基类中有一个不可访问或删除掉的析构函数，则派生类中合成的默认和拷贝构造函数将是被删除的，因为编译器无法销毁派生类对象的基类部分
  
  + 编译器将不会合成一个删除掉的移动操作。当使用=default请求一个移动操作时，如果基类中的对应操作是删除的或不可访问的，那么派生类中该函数将是被删除的，原因是派生类对象的基类部分不可移动，同样，如果基类的析构函数是删除的或不可访问的，则派生类的移动构造函数也将是被删除的。

#### 15.7.3 派生类的拷贝控制成员

+ 析构函数只负责销毁派生类自己分配的资源

+ 派生类的赋值运算符也必须显式地为其基类部分赋值

+ 对象销毁地顺序正好与其创建地顺序相反：派生类地析构函数首先执行，然后是基类地析构函数，依次类推，沿着继承体系地反方向直至最后。



#### 15.7.4 继承的构造函数

+ 通常情况下，using声明语句只是令某个名字在当前作用域内可见，而当作用于构造函数时，using声明语句将令编译器产生代码

+ 和普通成员的using声明不一样的是，一个构造函数的using声明不会改变该构造函数的访问级别

+ 一个using声明不能指定explicit或constexpr，如果基类的构造函数是explicit或者constexpr,则继承的构造函数也拥有相同的属性

+ 当一个基类构造函数含有默认实参时，这些实参并不会被继承，相反，派生类将获得多个继承的构造函数，其中每个构造函数分别省略掉一个含有默认实参的形参



### 15.8 容器与继承

+ 当我们使用容器存放继承体系中的对象时，通常必须采取间接存储的方式，因为不允许在容器中保存不同类型的元素，所以我们不能把具有继承关系的多种类型的对象直接存放在容器中

+ 实际存放的通常是基类的指针（更好的选择是智能指针）

#### 15.8.1 编写Basket类

+ 对于C++面向对象的编程来说，一个悖论是我们无法直接使用对象进行面向对象编程，相反，必须使用指针和引用，因为指针会增加程序的复杂性，所以经常定义一些辅助的类来处理这种复杂的情况




