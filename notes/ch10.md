## 第十章 泛型算法
  + 用户在容器可能需要一些常见的操作，例如查找特定元素、替换或删除一个特定值、重排元素顺序等，标准库没有给每个容器都定义成员函数来实现这些操作，而是定义了一组泛型算法。实现了一些经典算法的公共接口，可以用于不同类型的元素和多种容器类型

### 10.1 概述
  + 大多数算法都定义在头文件algorithm中，标准库在头文件numeric中也定义了一组数值泛型算法
  + 一般情况下，这些算法并不直接操作容器，而是遍历两个迭代器指定的一个元素范围。
  + 我们有一个int的vector，希望直到这个vector中是否包含一个特定值，可以调用标准库算法find。`auto result = find(vec.begin(),vec.end(),val);`，前两个参数表示元素范围的迭代器，弟弟三个参数是一个值，返回指向第一个等于给定值的元素的迭代器，如果范围内无匹配元素，则find返回第二个参数来表示搜索失败
  + 概念上，find的执行步骤：
    + 访问序列中的首元素
    + 比较此元素与我们要查找的值
    + 如果此元素与我们要查找的值匹配，find返回标识此元素的值
    + 否则，find前进到下一个元素，重复执行步骤2和3
    + 如果到达序列尾，find应停止
    + 如果find到达序列末尾，它应该返回一个指出元素未找到的值。此值和步骤3返回的值必须具有相容的类型
  + 迭代器令算法不依赖于容器，单算法依赖于元素类型的操作，大多数算法提供了一种方法，允许我们使用自定的操作来代替默认的运算符
  + 泛型算法本身不会执行容器的操作，它们只会运行于迭代器之上，执行迭代器的操作，算法永远不会改变底层容器的大小

### 10.2 初识泛型算法
#### 10.2.1 只读算法
  + 一些算法只会读取其输入范围内的元素，而从不改变元素，find是，accumulate也是，定义在头文件numeric中，接受三个参数，前两个指出需要求和的元素的范围，第三个参数是和的初值，`int sum = accumulate(vec.cbegin(),vec.cend(),0);`，这条语句将sum设置为vec中的和，和的初值被设置为0
  + accumulate将第三个参数作为求和起点，这蕴含着一个编程假定：将元素类型加到和的类型上的操作必须是可行的，还可以拼接string，`string sum=accumulate(v.cbegin(),v.cend(),string("")) ;`,这里将空串当作一个字符串字面值传递给第三个参数是不可以的，会导致一个编译错误，因为如果我们传递了一个字符串字面值，用于保存和的对象的类型将是const char\*，但是const chat\*没有+运算符，此调用会产生编译错误
  + 对于只读取而不改变元素的算法，通常最好使用cbegin()和cend()，如果你计划使用算法返回的迭代器来改变元素的值，就需要使用begin()和end()的结果作为参数。
  + equal也是只读算法，用于确定两个序列是否保存相同的值，只有所有对应元素都相等，才返回true，否则返回false，前两个表示第一个序列中的元素范围，第三个表示第二个序列中的首元素
  + 由于equal利用迭代器完成操作，因此可以通过调用equal来比较两个不同类型的容器中的元素，而且元素类型也不必一样，只要能用==来比较元素类型即可。但是这里假设第二个序列至少与第一个序列一样长。
  + 哪些只接受一个单一迭代器来表示第二个序列的算法，都假定第二个序列至少与第一个序列一样长

