## 第九章 顺序容器
  + 一个容器就是一些特定类型对象的集合。顺序容器为程序员提供了控制元素存储和访问顺序的能力
### 9.1 顺序容器概述
  + 所有顺序容器都提供了快速顺序访问元素的能力，但是在以下方面都有不同的性能分析：
    + 向容器添加或从容器中删除元素的代价
    + 非顺序访问容器中元素的代价
  + 顺序容器类型：
    | 容器 | 含义 |
    | :----- | :----- |
    | vector | 可变大小数组。支持快速随机访问。在尾部之外的位置插入或删除元素可能很慢 | 
    | deque | 双端队列。支持快速随机访问，在头尾位置插入/删除速度很快 |
    | list | 双向链表。只支持双向顺序访问。在list中任何位置进行插入/删除操作速度都很快 |
    | forward_list | 单向链表。只支持单向顺序访问。在链表任何位置进行插入/删除速度都很快 |
    | array | 固定大小数组。支持快速随机访问。不能添加或删除元素 | 
    | string | 与vector相似的容器。但专门用于保存字符。随机访问速度快。在尾部插入/删除速度快 |
  + string和vector将元素保存在连续的内存空间中。由于元素是连续存储的，由元素的下标来计算其地址是非常快速的。但是，在这两种容器的中间位置添加或删除元素就会非常耗时：在一次插入或删除操作后，需要移动插入/删除位置之后的所有元素，来保持连续存储。而且，添加一个元素有时间可能还需要分配额外的存储空间。在这种情况下，每个元素都必须移动到新的存储空间中。
  + list和forward_list两个容器的设计目的是令容器任何位置的添加或删除操作都很快速。作为代价，这两个容器不支持元素的随机访问：为了访问一个元素，我们只能遍历整个容器。而且，与vector、deque和array相比，这两个容器的额外内存开销也很大
  + deque是一个更外复杂的数据结构，与string和vector类似，deque支持快速的随机访问。与string和vector一样，在deque的中间位置添加或删除元素的代价（可能）很高。但是，在deque的两端添加或删除元素都是很快的，与list或forward_list添加删除元素的速度相当
  + forward_list和array是新C+++标准增加的类型。与内置数组相比，array是一种更安全，更容易使用的数组类型。与内置数组类似，array对象的大小是固定的。因此，array不支持添加和删除元素以及改变容器大小的操作。forward_list的设计目标是达到与最好的手写的单向链表数据结构相当的性能。因此，forward_list没有size操作，因为保存或计算其大小就会比手写链表多出额外的开销，对其他容器而言，size保证是一个快速的常量时间的操作。
  + 新标准库容器的性能几乎肯定与最精心优化过的同类数据结构一样好（通常会更好）。现在C++程序员应该使用标准库容器，而不是更原始的数据结构，如内置数组。
  + 选择容器的基本原则：
    + 除非你有很好的理由选择其他容器，否则应使用vector
    + 如果你的程序有很多小的元素，且空间的的额外开销比较重要，则不要使用list或forward_list
    + 如果程序要求随机访问元素，应使用vector或deque
    + 如果程序要求在容器的中间插入或删除元素，应使用list或forward_list
    + 如果程序需要在头尾位置插入或删除元素，但不会在中间位置进行插入或删除操作，则使用deque
    + 如果程序只有在读取输入时才需要在容器中间位置插入元素，随后需要随机访问元素，则
      + 首先，确定是否真的需要在容器中间位置添加元素。当处理输入数据时，通常可以很容器地向vector追加数据，然后调用标准库地sort函数来重排容器中地元素，从而避免在中间位置添加元素
      + 如果必须在中间位置插入元素，考虑在输入阶段使用list，一旦输入完成，将list中地内容拷贝到一个vector中

### 9.2 容器库概览
  + 容器类型上的操作形成了一种层次：
    + 某些操作是所有容器都提供的（参见表9.2）
    + 另外一些操作仅针对顺序容器（参见表9.3），关联容器（参见表11.7），或无序容器（参见表11.8）
    + 还有一些操作只适用于一小部分容器
  + 一般来说，每各容器都定义在一个头文件中，文件名与类型名相同，容器均定义为模板类
  + 顺序容器几乎可以保存任意类型的元素
  + 表9.2容器操作
    | 类型别名 | 含义 |
    | :----- | :----- |
    | iterator | 此容器类型的迭代器类型 |
    | const_iterator | 可以去读元素，但不能修改元素的迭代器类型 |
    | size_type | 无符号整数类型，足够保存此种容器类型类型最大可能容器的大小 | 
    | difference_type | 带符号整数类型，足够保存两个迭代器之间的距离 | 
    | value_type | 元素类型 |
    | reference | 元素的左值类型，与value_type&含义相同 |
    | const_reference | 元素的const左值类型，即const value_type& |
    | **构造函数** | **含义** |
    | C c; | 默认构造函数，构造空容器 | 
    | C c1(c2); | 构造c2的拷贝c1 |
    | C c(c,e); | 构造c,将迭代器b和e指定的范围内的元素拷贝到c(array不支持) |
    | C c{a,b,c...}; | 列表初始化c |
    | **赋值与swap** | **含义** |
    | c1 = c2; | 将c1中的元素替换为c2中元素 |
    | c1 = {a,b,c...} | 将c1中的元素替换为列表中元素（不适用于array）|
    | a.swap(b) | 交换a和b的元素 |
    | swap(a,b) | 与a.swap(b)等价| 
    | **大小** | **含义** |
    | c.size() | c中元素的数目，不支持forward_list | 
    | c.max_size() | c中可保存的最大元素数目 |
    | c.empty() | 若c中存储了元素，返回false，否则返回true |
    | **添加/删除元素(不适用于array)(不同容器中，这些操作的接口都不同)** | **含义** |
    | c.insert(args) | 将args中的元素拷贝进c |
    | c.emplace(inits) | 使用inits构造c中的一个元素 |
    | c.erase(args) | 删除args指定的元素 |
    | c.clear() | 删除c中所有元素，返回void |
    | **关系运算符** | **含义** |
    | ==,!= | 所有容器都支持相等（不等）运算符 |
    | <,<=,>,>= | 关系运算符（无序容器不支持） |
    | **获取迭代器** | **含义** |
    | c.begin(),c.end() | 返回指向c的首元素和尾元素之后位置的迭代器 |
    | c.cbegin(),c.cend() | 返回const_iterator |
    | **反向容器的额额外成员（不支持forward_list）** | **含义** |
    | reverse_iterator | 按逆序寻址元素的迭代器 |
    | const_reverse_iterator | 不能修改元素的逆序迭代器 |
    | c.rbegin(),c.rend() | 返回指向c的尾元素和首元素之前位置的迭代器 |
    | c.crbegin(),c.crend() | 返回const+reverse_iterator |
    
#### 9.2.1 迭代器
  + 与容器一样，迭代器有着公共的接口：如果一个迭代器提供某个操作，那么所有提供相同操作的迭代器对这个操作的实现方式都是相同的。forward_list不支持递减运算符
  + 一个迭代器范围由一对迭代器表示，两个迭代器分别指向同一个容器中的元素或者是尾元素之后的位置
  + 迭代器范围都是左闭合区间\[begin,end),迭代器begin和end必须指向相同的容器，end可以和begin指向相同的位置，但不能指向begin之前的位置
  + 标准库使用左闭合范围是因为这种范围有三种方便的性质：
    + 如果begin和end相等，则范围为空
    + 如果begin与end不等，则范围至少包含一个元素，且begin指向该范围中的第一个元素
    + 我们可以对begin递增若干次，使得begin==end
  
#### 9.2.2 容器类型成员
  + 大多数容器都提供反向迭代器，是一种反向遍历容器的迭代器，与正向迭代器相比，各种操作的含义也都发生了颠倒。例如，对于一个反向迭代器执行++操作，会得到上一个元素
  + 通过类型别名，我们可以在不了解容器中元素类型的i情况下使用它，为了使用这些类型，我们必须显式地使用其类名

#### 9.2.3 begin和end成员
  + 不以c开头的函数都是被重载过的，实际上有两个名为begin()的成员，一个是const成员，返回容器的const_iterator,一个是非常量成员，返回容器的iterator类型
  + 当auto与begin或end结合使用时，获得的迭代器类型依赖于容器类型，与我们想要如何使用迭代器毫不相干

#### 9.2.4 容器定义和初始化
  + 容器定义和初始化：
    | 操作 | 含义 |
    | :----- | :----- |
    | C c; | 默认构造函数。如果c是一个array，则c中元素按默认方式初始化，否则c为空 |
    | C c1(c2);<br>C c1 = c2; | c1初始化为c2的拷贝，c1和c2必须是相同类型，即它们必须是相同的容器类型，且保存的是相同的元素类型，对于array类型，两者还必须具有相同的大小|
    | C c{a,b,c...};<br>C c={a,b,c...} | c初始化为初始化列表中元素的拷贝。列表中元素的类型必须与C的元素类型相容。对于array类型，列表中元素的数目必须等于或小于array的大小，任何一楼的元素都进行值初始化|
    | C c(b,e) | c初始化为迭代器b和e指定范围中的元素的拷贝。范围中元素的类型必须与C的元素类型相容(array不适用) |
    | 只有顺序容器(不包括array)的构造函数才能接受大小参数 | |
    | C seq(n); | seq包含n个元素，这些元素进行了值初始化，此构造函数是explicit的(string不适用) |
    | C seq(n,t) | seq包含n个初始化为值t的元素 |
  + 将一个新容器创建为另一个容器的拷贝有两种方法：
    + 直接拷贝整个容器
    + 拷贝一个迭代器对指定的元素范围（array除外）
  + 为了创建一个容器为另一个容器的拷贝，两个容器的类型及其元素类型必须匹配，不过，当传递迭代器参数来拷贝一个范围时，就不要求容器类型是相同的，而且新容器和原容器中的元素类型也可以不同，只要能将要拷贝的元素转换为初始化的元素类型即可
  + 当定义一个array时，除了指定元素类型，还要指定容器大小。
    ```cpp
    array<int, 42> a;
    array<int. 42>::size_type i;
    ```
    由于大小是array类型的一部分，所以array不支持普通的容器构造函数
  + 虽然我们不能对内置数组类型进行拷贝或对象赋值操作，但是array并没有这样的限制

#### 9.2.5 赋值和swap
  + 与内置数组不同，标准库array类型允许赋值。赋值号左右两边的原酸对象必须具有相同的类型。
    ```cpp
    array<int,10> a1={0,1,2,3,4,5,6,7,8,9};
    array<int, 10> a2 = {0};
    a1 = a2;
    a2 = {0};//错误，不能将一个花括号列表赋予数组
    ```
    由于右边运算符对象大小可能与左边运算u第项的大小不同，因此array类型不支持assign，也不允许用花括号包围的值列表进行赋值
  + 容器赋值运算：
    | c1=c2 | 将c1中的元素替换为c2中元素的拷贝，c1和c2必须具有相同的类型 |
    | c={a,b,c...} | 将c中元素替换为初始化列表中元素的拷贝(array不适用) |
    | swap(c1,c2)<br>c1.swap(c2) | 交换c1和c2中的元素，c1和c2必须具备相同的类型，swap通常比从c2向c1拷贝元素快得多 |
    | assign操作不适用于关联容器和array | |
    | seq.assign(b,e) | 将seq中的元素替换为迭代器b和e所表示的范围中的元素。迭代器b和e不能指向seq中的元素 |
    | seq.assign(i1) | 将seq中的元素替换为初始化列表i1中的元素 |
    | seq.assigne(n,t) | 将seq中的元素替换为n个值为t的元素 |
  + 赋值相关运算会导致指向左边容器内部的迭代器、引用和指针失效。而swap操作将容器内容交换不会导致指向容器的迭代器、引用和指针失效（容器类型为array和string的情况除外）
  + assign允许我们从一个不同但相容的类型赋值，或者从容器的一个子序列赋值
  + 由于assign的调用对象的旧元素被替换，因此传递给assign的迭代器不能指向调用assign的容器
  + 交换两个容器内容的操作保证会很快，因为元素本身并未交换，swap只是交换了两个容器的内部数据结构
  + 除array外，swap不对任何元素进行拷贝、删除或插入操作，因此可以保证在常数时间内完成
  + 与其他容器不同，swap两个array会真正交换它们的元素，因此，交换两个array所需的时间和array中元素的数目成正比。因此对于array，在swap操作之后，指针、引用和迭代器所绑定的元素保持不变，但元素值已经与另一个array中对应元素的值进行了交换
  + 统一使用非成员版本的swap是一个好习惯

#### 9.2.6 容器大小操作
  + 除了forward_list外，每个容器类型都有三个与大小相关的操作。成员函数size返回容器中元素的数目，empty当size为0时返回true否则返回fasle，max_size返回一个大于或等于该类型容器所能容纳的最大元素数的值。forward_list不支持size

#### 9.2.7 关系运算符
  + 每个容器都支持相等运算符（==和!=），除了无序关联容器外的所有容器都支持关系运算符(>,>=,<,<=)。关系运算符左右两边的运算对象必须是相同类型的容器，且必须保存相同类型的元素。
  + 比较两个容器实际上是进行元素的逐对比较：
    + 如果两个容器具有相同大小，且所有元素都两两对应相等，则这两个容器相等，否则两个容器不等
    + 如果两个容器大小不同，但较小容器中每个元素都等于较大容器中的对应元素，则较小容器小于较大容器
    + 如果两个容器都不是另一个容器的前缀子序列，则它们的比较结果取决于第一个不相等的元素的比较结果。
  + 只有当容器元素类型也定义了相应的比较运算时，我们才可以使用关系运算符来比较两个容器



