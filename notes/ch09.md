## 第九章 顺序容器
  + 一个容器就是一些特定类型对象的集合。顺序容器为程序员提供了控制元素存储和访问顺序的能力
### 9.1 顺序容器概述
  + 所有顺序容器都提供了快速顺序访问元素的能力，但是在以下方面都有不同的性能分析：
    + 向容器添加或从容器中删除元素的代价
    + 非顺序访问容器中元素的代价
  + 顺序容器类型：
    | 容器 | 含义 |
    | :----- | :----- |
    | vector | 可变大小数组。支持快速随机访问。在尾部之外的位置插入或删除元素可能很慢 | 
    | deque | 双端队列。支持快速随机访问，在头尾位置插入/删除速度很快 |
    | list | 双向链表。只支持双向顺序访问。在list中任何位置进行插入/删除操作速度都很快 |
    | forward_list | 单向链表。只支持单向顺序访问。在链表任何位置进行插入/删除速度都很快 |
    | array | 固定大小数组。支持快速随机访问。不能添加或删除元素 | 
    | string | 与vector相似的容器。但专门用于保存字符。随机访问速度快。在尾部插入/删除速度快 |
  + string和vector将元素保存在连续的内存空间中。由于元素是连续存储的，由元素的下标来计算其地址是非常快速的。但是，在这两种容器的中间位置添加或删除元素就会非常耗时：在一次插入或删除操作后，需要移动插入/删除位置之后的所有元素，来保持连续存储。而且，添加一个元素有时间可能还需要分配额外的存储空间。在这种情况下，每个元素都必须移动到新的存储空间中。
  + list和forward_list两个容器的设计目的是令容器任何位置的添加或删除操作都很快速。作为代价，这两个容器不支持元素的随机访问：为了访问一个元素，我们只能遍历整个容器。而且，与vector、deque和array相比，这两个容器的额外内存开销也很大
  + deque是一个更外复杂的数据结构，与string和vector类似，deque支持快速的随机访问。与string和vector一样，在deque的中间位置添加或删除元素的代价（可能）很高。但是，在deque的两端添加或删除元素都是很快的，与list或forward_list添加删除元素的速度相当
  + forward_list和array是新C+++标准增加的类型。与内置数组相比，array是一种更安全，更容易使用的数组类型。与内置数组类似，array对象的大小是固定的。因此，array不支持添加和删除元素以及改变容器大小的操作。forward_list的设计目标是达到与最好的手写的单向链表数据结构相当的性能。因此，forward_list没有size操作，因为保存或计算其大小就会比手写链表多出额外的开销，对其他容器而言，size保证是一个快速的常量时间的操作。
  + 新标准库容器的性能几乎肯定与最精心优化过的同类数据结构一样好（通常会更好）。现在C++程序员应该使用标准库容器，而不是更原始的数据结构，如内置数组。
  + 选择容器的基本原则：
    + 除非你有很好的理由选择其他容器，否则应使用vector
    + 如果你的程序有很多小的元素，且空间的的额外开销比较重要，则不要使用list或forward_list
    + 如果程序要求随机访问元素，应使用vector或deque
    + 如果程序要求在容器的中间插入或删除元素，应使用list或forward_list
    + 如果程序需要在头尾位置插入或删除元素，但不会在中间位置进行插入或删除操作，则使用deque
    + 如果程序只有在读取输入时才需要在容器中间位置插入元素，随后需要随机访问元素，则
      + 首先，确定是否真的需要在容器中间位置添加元素。当处理输入数据时，通常可以很容器地向vector追加数据，然后调用标准库地sort函数来重排容器中地元素，从而避免在中间位置添加元素
      + 如果必须在中间位置插入元素，考虑在输入阶段使用list，一旦输入完成，将list中地内容拷贝到一个vector中

### 9.2 容器库概览
  + 容器类型上的操作形成了一种层次：
    + 某些操作是所有容器都提供的（参见表9.2）
    + 另外一些操作仅针对顺序容器（参见表9.3），关联容器（参见表11.7），或无序容器（参见表11.8）
    + 还有一些操作只适用于一小部分容器
  + 一般来说，每各容器都定义在一个头文件中，文件名与类型名相同，容器均定义为模板类
  + 顺序容器几乎可以保存任意类型的元素
  + 表9.2容器操作
    | 类型别名 | 含义 |
    | :----- | :----- |
    | iterator | 此容器类型的迭代器类型 |
    | const_iterator | 可以去读元素，但不能修改元素的迭代器类型 |
    | size_type | 无符号整数类型，足够保存此种容器类型类型最大可能容器的大小 | 
    | difference_type | 带符号整数类型，足够保存两个迭代器之间的距离 | 
    | value_type | 元素类型 |
    | reference | 元素的左值类型，与value_type&含义相同 |
    | const_reference | 元素的const左值类型，即const value_type& |
    | **构造函数** | **含义** |
    | C c; | 默认构造函数，构造空容器 | 
    | C c1(c2); | 构造c2的拷贝c1 |
    | C c(c,e); | 构造c,将迭代器b和e指定的范围内的元素拷贝到c(array不支持) |
    | C c{a,b,c...}; | 列表初始化c |
    | **赋值与swap** | **含义** |
    | c1 = c2; | 将c1中的元素替换为c2中元素 |
    | c1 = {a,b,c...} | 将c1中的元素替换为列表中元素（不适用于array）|
    | a.swap(b) | 交换a和b的元素 |
    | swap(a,b) | 与a.swap(b)等价| 
    | **大小** | **含义** |
    | c.size() | c中元素的数目，不支持forward_list | 
    | c.max_size() | c中可保存的最大元素数目 |
    | c.empty() | 若c中存储了元素，返回false，否则返回true |
    | **添加/删除元素(不适用于array)(不同容器中，这些操作的接口都不同)** | **含义** |
    | c.insert(args) | 将args中的元素拷贝进c |
    | c.emplace(inits) | 使用inits构造c中的一个元素 |
    | c.erase(args) | 删除args指定的元素 |
    | c.clear() | 删除c中所有元素，返回void |
    | **关系运算符** | **含义** |
    | ==,!= | 所有容器都支持相等（不等）运算符 |
    | <,<=,>,>= | 关系运算符（无序容器不支持） |
    | **获取迭代器** | **含义** |
    | c.begin(),c.end() | 返回指向c的首元素和尾元素之后位置的迭代器 |
    | c.cbegin(),c.cend() | 返回const_iterator |
    | **反向容器的额额外成员（不支持forward_list）** | **含义** |
    | reverse_iterator | 按逆序寻址元素的迭代器 |
    | const_reverse_iterator | 不能修改元素的逆序迭代器 |
    | c.rbegin(),c.rend() | 返回指向c的尾元素和首元素之前位置的迭代器 |
    | c.crbegin(),c.crend() | 返回const+reverse_iterator |
    
#### 9.2.1 迭代器
  + 与容器一样，迭代器有着公共的接口：如果一个迭代器提供某个操作，那么所有提供相同操作的迭代器对这个操作的实现方式都是相同的。forward_list不支持递减运算符
  + 一个迭代器范围由一对迭代器表示，两个迭代器分别指向同一个容器中的元素或者是尾元素之后的位置
  + 迭代器范围都是左闭合区间\[begin,end),迭代器begin和end必须指向相同的容器，end可以和begin指向相同的位置，但不能指向begin之前的位置
  + 标准库使用左闭合范围是因为这种范围有三种方便的性质：
    + 如果begin和end相等，则范围为空
    + 如果begin与end不等，则范围至少包含一个元素，且begin指向该范围中的第一个元素
    + 我们可以对begin递增若干次，使得begin==end
  
#### 9.2.2 容器类型成员
  + 大多数容器都提供反向迭代器，是一种反向遍历容器的迭代器，与正向迭代器相比，各种操作的含义也都发生了颠倒。例如，对于一个反向迭代器执行++操作，会得到上一个元素
  + 通过类型别名，我们可以在不了解容器中元素类型的i情况下使用它，为了使用这些类型，我们必须显式地使用其类名

#### 9.2.3 begin和end成员
  + 不以c开头的函数都是被重载过的，实际上有两个名为begin()的成员，一个是const成员，返回容器的const_iterator,一个是非常量成员，返回容器的iterator类型
  + 当auto与begin或end结合使用时，获得的迭代器类型依赖于容器类型，与我们想要如何使用迭代器毫不相干

#### 9.2.4 容器定义和初始化
  + 容器定义和初始化：
    | 操作 | 含义 |
    | :----- | :----- |
    | C c; | 默认构造函数。如果c是一个array，则c中元素按默认方式初始化，否则c为空 |
    | C c1(c2);<br>C c1 = c2; | c1初始化为c2的拷贝，c1和c2必须是相同类型，即它们必须是相同的容器类型，且保存的是相同的元素类型，对于array类型，两者还必须具有相同的大小|
    | C c{a,b,c...};<br>C c={a,b,c...} | c初始化为初始化列表中元素的拷贝。列表中元素的类型必须与C的元素类型相容。对于array类型，列表中元素的数目必须等于或小于array的大小，任何一楼的元素都进行值初始化|
    | C c(b,e) | c初始化为迭代器b和e指定范围中的元素的拷贝。范围中元素的类型必须与C的元素类型相容(array不适用) |
    | 只有顺序容器(不包括array)的构造函数才能接受大小参数 | |
    | C seq(n); | seq包含n个元素，这些元素进行了值初始化，此构造函数是explicit的(string不适用) |
    | C seq(n,t) | seq包含n个初始化为值t的元素 |
  + 将一个新容器创建为另一个容器的拷贝有两种方法：
    + 直接拷贝整个容器
    + 拷贝一个迭代器对指定的元素范围（array除外）
  + 为了创建一个容器为另一个容器的拷贝，两个容器的类型及其元素类型必须匹配，不过，当传递迭代器参数来拷贝一个范围时，就不要求容器类型是相同的，而且新容器和原容器中的元素类型也可以不同，只要能将要拷贝的元素转换为初始化的元素类型即可
  + 当定义一个array时，除了指定元素类型，还要指定容器大小。
    ```cpp
    array<int, 42> a;
    array<int. 42>::size_type i;
    ```
    由于大小是array类型的一部分，所以array不支持普通的容器构造函数
  + 虽然我们不能对内置数组类型进行拷贝或对象赋值操作，但是array并没有这样的限制

#### 9.2.5 赋值和swap
  + 与内置数组不同，标准库array类型允许赋值。赋值号左右两边的原酸对象必须具有相同的类型。
    ```cpp
    array<int,10> a1={0,1,2,3,4,5,6,7,8,9};
    array<int, 10> a2 = {0};
    a1 = a2;
    a2 = {0};//错误，不能将一个花括号列表赋予数组
    ```
    由于右边运算符对象大小可能与左边运算u第项的大小不同，因此array类型不支持assign，也不允许用花括号包围的值列表进行赋值
  + 容器赋值运算：
    | c1=c2 | 将c1中的元素替换为c2中元素的拷贝，c1和c2必须具有相同的类型 |
    | c={a,b,c...} | 将c中元素替换为初始化列表中元素的拷贝(array不适用) |
    | swap(c1,c2)<br>c1.swap(c2) | 交换c1和c2中的元素，c1和c2必须具备相同的类型，swap通常比从c2向c1拷贝元素快得多 |
    | assign操作不适用于关联容器和array | |
    | seq.assign(b,e) | 将seq中的元素替换为迭代器b和e所表示的范围中的元素。迭代器b和e不能指向seq中的元素 |
    | seq.assign(i1) | 将seq中的元素替换为初始化列表i1中的元素 |
    | seq.assigne(n,t) | 将seq中的元素替换为n个值为t的元素 |
  + 赋值相关运算会导致指向左边容器内部的迭代器、引用和指针失效。而swap操作将容器内容交换不会导致指向容器的迭代器、引用和指针失效（容器类型为array和string的情况除外）
  + assign允许我们从一个不同但相容的类型赋值，或者从容器的一个子序列赋值
  + 由于assign的调用对象的旧元素被替换，因此传递给assign的迭代器不能指向调用assign的容器
  + 交换两个容器内容的操作保证会很快，因为元素本身并未交换，swap只是交换了两个容器的内部数据结构
  + 除array外，swap不对任何元素进行拷贝、删除或插入操作，因此可以保证在常数时间内完成
  + 与其他容器不同，swap两个array会真正交换它们的元素，因此，交换两个array所需的时间和array中元素的数目成正比。因此对于array，在swap操作之后，指针、引用和迭代器所绑定的元素保持不变，但元素值已经与另一个array中对应元素的值进行了交换
  + 统一使用非成员版本的swap是一个好习惯

#### 9.2.6 容器大小操作
  + 除了forward_list外，每个容器类型都有三个与大小相关的操作。成员函数size返回容器中元素的数目，empty当size为0时返回true否则返回fasle，max_size返回一个大于或等于该类型容器所能容纳的最大元素数的值。forward_list不支持size

#### 9.2.7 关系运算符
  + 每个容器都支持相等运算符（==和!=），除了无序关联容器外的所有容器都支持关系运算符(>,>=,<,<=)。关系运算符左右两边的运算对象必须是相同类型的容器，且必须保存相同类型的元素。
  + 比较两个容器实际上是进行元素的逐对比较：
    + 如果两个容器具有相同大小，且所有元素都两两对应相等，则这两个容器相等，否则两个容器不等
    + 如果两个容器大小不同，但较小容器中每个元素都等于较大容器中的对应元素，则较小容器小于较大容器
    + 如果两个容器都不是另一个容器的前缀子序列，则它们的比较结果取决于第一个不相等的元素的比较结果。
  + 只有当容器元素类型也定义了相应的比较运算时，我们才可以使用关系运算符来比较两个容器

### 9.3 顺序容器操作
#### 9.3.1 向顺序容器添加元素
  + 向顺序容器中添加元素的操作（这些操作会改变容器大小：array不支持这些操作），：
    forward_list有自己专门的insert和emplace，forward_list不支持push-back和emplace_back
    vector和string不支持push_front和emplace_front
    | 操作 | 含义 |
    | :----- | :----- |
    | c.push_back(t)<br>c.emplace_back(args) | 在c的尾部创建一个值为t或由args创建的元素。返回void |
    | c.push_front()<br>c.emplace_back(args) | 在c的头部创建一个值为t或由args创建的元素。返回void |
    | c.insert(p,t)<br>c.emplace(p,args) | 在迭代器p指向的元素之前创建一个值为t或由args创建的元素。返回指向新添加的元素的迭代器 |
    | c.insert(p,n,t) | 在迭代器p指向的元素之前插入n个值为t的元素。返回指向新添加的第一个元素的迭代器，若n为0,则返回p |
    | c.insert(p,b,e) | 将迭代器b和e指定的范围内的元素插入到迭代器p指向的元素之前。b和e不能指向c中的元素。返回指向新添加的第一个元素的迭代器，若返回为空，返回p |
    | c.insert(p,il) | il是一个花括号包围的元素值列表。将这些给定的值插入到迭代器p指向的元素之前。返回指向新添加的第一个元素的迭代器，若列表为空，则返回p |
    向一个vector，string或deque插入元素会使所有指向容器的迭代器、引用和指针失效
  + 当我们用一个对象来初始化容器时，或将一个对象插入到容器中时，实际上放入到容器中的是对象值得一个拷贝，而不是对象本身
  + emplace_front,emplace_back,emplace这些操作构造而不是拷贝元素。当我们调用一个emplace成员函数时，则是将参数传递给元素类型的构造函数。emplace成员使用这些参数在容器管理的内存空间中直接构造元素

#### 9.3.2 访问元素
  + 包括array在内的每个顺序容器都有一个front成员函数，而除forward_list之外的所有容器都有一个back成员函数。这两个操作分别返回首元素和尾元素的引用
  + 顺序容器中访问元素的操作（at和下标只适用于string,vector,deque,array）(back不适用于forward_list)：
    | 操作 | 含义| 
    | :----- | :----- |
    | c.back() | 返回c中尾元素的引用。若c为空，函数行为未定义 |
    | c.front() | 返回c中首元素的引用。若c为空，函数行为未定义 |
    | c\[n\] | 返回c中下标为n的元素的引用，n是一个无符号整数。若n>=c.size(),则函数行为未定义 |
    | c.at(n) | 返回下标为n的元素的引用。如果下标越界，则抛出一个out_of_range异常 |
    对一个空容器调用front和back，就像使用一个越界的下标一样，是一种严重的程序设计错误 
  + 如果容器是一个const对象，则返回值是const的引用。如果容器不是const的，则返回值是普通引用，我们可以用来改变元素的值
    ```cpp
    auto &v=c.back(); //返回指向最后一个元素的引用
    auto v2=c.back();//v2不是一个引用，它是c.back()的一个拷贝
    ```
  + 如果我们希望确保下标是合法的，可以使用at成员函数

#### 9.3.3 删除元素
  + 顺序容器的删除操作（这些操作会改变容器的大小，所以不适用于array）(forward_list有特殊版本的erase，不支持pop_back;vector和string不支持pop_front)：  
    | 操作 | 含义 |
    | :----- | :----- |
    | c.pop_back() | 删除c中尾元素。若c为空，则函数行为未定义。函数返回void |
    | c.pop_fron() | 删除c中首元素。若c为空，则函数行为未定义。函数返回void |
    | c.erase(p) | 删除迭代器p所指定的元素，返回一个被删元素之后元素的迭代器，若p指向尾元素，则返回尾后迭代器。若p是尾后迭代器，则函数行为未定义 |
    | c.erase(b,e) | 删除迭代器b和e所指定范围内的元素。返回一个指向最后一个被删除元素之后元素的迭代器，若e本身就是尾后迭代器，则函数页返回尾后迭代器 |
    | c.clear() | 删除c中的所有元素，返回void |
  + 删除deque中除首尾位置之外的任何元素都会使所有迭代器、引用、指针失效。指向vector或string中删除点之后位置的迭代器、引用和指针都会失效

#### 9.3.4 特殊的forward_list操作
  + 当添加或删除一个元素时，删除或添加的元素之前的那个元素的后继会发生改变。为了添加或删除一个元素，我们需要访问其前驱，以改变前驱的链接。但是forward_list是单向链表。在一个单向链表中，没有简单的方法来获取一个元素的前驱。出于这个原因，在一个forward_list中添加或删除元素的操作是通过改变给定元素之后的元素来完成的。这样，我们总是可以访问到被添加或删除操作所影响的元素
  + 在forward_list中插入或删除元素的操作
    | 操作 | 含义 |
    | :----- | :----- |
    | lst.before_begin()<br>lst.cbefore_begin() | 返回指向链表首元素之前不存在的元素的迭代器。此迭代器不能解引用,cbefore_begin()返回一个const_iterator| 
    | lst.insert_after(p,t)<br>lst.insert(p,n,t)<br>lst.insert_after(p,b,e)<br>lst.insert_after(p,il) | 在迭代器p之后的位置插入元素。t是一个对象，n是数量，b和e是表示范围的一对迭代器（b和e不能指向lst内），il是一个花括号列表。返回一个指向u子厚一个插入元素的迭代器。如果范围为空，则返回p.如果p是尾后迭代器，则函数行为未定义 |
    | lst.emplace_sfter(p,args) | 使用args在p指定的位置之后创建一个元素。返回一个指向这个新元素的迭代器。若p为尾后迭代器，则函数行为未定义 |
    | lst.erase_after(p)<br>lst.erase(b,e) | 删除p指向的位置之后的元素，或删除从b之后直到（但不包含）e之间的元素。返回一个指向被删元素之后元素迭代器，若不存在这样的元素，则返回尾后迭代器。如果p指向lst尾元素或者是一个尾后迭代器，则函数行为未定义 |

#### 9.3.5 改变容器的大小
  + 如果当前大小大于容器所要求的大小，容器后面的元素会被删除；如果当前大小小于新大小，会将新元素添加到容器后面  
  + 顺序容器大小操作(不适用于array)：
    | 操作 | 含义 |
    | :----- | :----- |
    | c.resize(n) | 调整c的大小为n个元素。若n\<c.size(),则多出的元素被丢弃。若必须添加新元素，对新元素进行值初始化 |
    | c.resize(n,t) | 调整c的大小为n个元素，任何新添加而的元素都初始化值为t |
  + 如果resize缩小容器，则指向被删除元素的迭代器、引用和指针都会失效；对vector,string或deque进行resize可能导致迭代器、指针和引用失效
  + 如果容器保存的是类类型元素，且resize向容器添加新元素，则我们必须提供初始值，或者元素类型必须提供一个默认构造函数

#### 9.3.6 容器操作可能使迭代器失效
  + 向容器添加元素后：
    + 如果容器是vector或string，且存储空间被重新分配，则指向容器的迭代器、指针和引用都会失效。如果存储空间未重新分配，指向插入位置之前的元素的迭代器、指针和引用仍有效，但只想插入位置之后的迭代器、指针和引用都会失效
    + 对于deque，插入到除首尾位置之外的任何位置都会导致迭代器、指针和引用失效。如果在首尾位置添加元素，迭代器会失效，但指向存在的元素的引用和指针不会失效
    + 对于list和forward_list，指向容器的迭代器、指针和引用仍有效
  + 删除元素：
    + 对于list和forward_list，指向容器其他位置的迭代器、引用和指针都有效
    + 对于deque，如果在首尾之外的任何位置删除元素，那么指向删除元素外的迭代器、引用和指针也会失效。如果删除deque的尾元素，则尾后迭代器会失效，但其他迭代器、引用和指针不受影响，如果删除首元素，这些也不会受影响
    + 对于vector和string，指向被删元素之前元素的迭代器、引用和指针仍有效。
  + 注意，当我们删除元素时，尾后迭代器总是会失效，使用失效的迭代器、引用和指针式严重的运行时错误
  + 当你使用迭代器（或指向容器元素的指针或引用）时，最小化要求迭代器必须保持有效的程序片段是一个好的办法
  + 添加或删除元素的循环程序必须反复调用end，而不能在循环之前保存end返回的迭代器，一直当作容器末尾使用

### 9.4 vector对象是如何增长的
  + 当不得不获取新的内存空间时，vector和string的实现通常会分配比新的空间需求更大的内存空间，这样就不需要每次添加新元素都重新分配容器的内存空间了
  + 容器大小管理操作（shrink_to_fit只适用于vector，stirng和deque）(capacity和reserve只适用于vector和string)：
    | 操作 | 含义 |
    | :----- | :----- |
    | c.shrink_to_fit() | 请将capacity()减少为与size()相同大小 |
    | c.capacity() | 不重新分配内存空间的话，c可以保存多少元素 |
    | c.size() | 分配至少能容纳n个元素的内存空间 |
    | c.reserve(n) | 分配至少能容纳n个元素的空间|
    reserve并不改变容器中元素的数量，它仅一行爱那个vector预先分配多大的内存空间
  + 只有当需要的内存空间超过当前容量时，reserve调用才会改变vector的容量。如果需求大小大于当前容量，reserve至少分配与需求一样大的内存空间（可能更大）
  + 调用reserve永远也不会减少容器占用的内存空间，reisze()成员函数只改变容器中元素的数目，而不是容器的容量
  + 调用shrink_to_fot并不保证一定退回内存空间
  + 从技术角度将。通过在一个初始化为空的vector上调用n次push_back来创建一个n个元素的vector，所花费的时间不能超过n的常数倍

### 9.5 额外的string操作
#### 9.5.1 构造string的其他方法
  + 构造string的其他方法（n,len2,pos2都是无符号值）：
    | 操作 | 含义 |
    | :----- | :----- |
    | string s(cp,n); | s是cp指向的数组中前n个字符的拷贝，此数组至少应该包含n个字符 |
    | string s(s2,pos2); | s是string s2从下标pos2开始的字符的拷贝。若pos2\>s2.size(),构造函数行为未定义 |
    | string s(s2,pos2,len2); | s是string s2从下标pos2开始len2个字符的拷贝。若pos2>s2.size(),构造函数行为未定义。不管len2的值是多少，构造函数至多拷贝s2.size()-pos2个字符|
  + 通常当我们从一个const char\*创建string时，指针指向的数组必须以空字符结束，拷贝操作遇到空字符时停止。如果我们还传递给构造函数一个计数值，数组就不必以空字符结尾。如果我们未传递计数值且数组也未以空字符结尾，或者给定计数值大于数组大小，则构造函数行为是未定义的
  + substr操作返回一个string,它是原始string的一部分或全部的拷贝，可以传递给substr一个可选的开始位置和计数值。如果开始位置超过了string的大小，则substr函数抛出一个out_of_range异常。如果开始位置加上计数值大于string的大小，则substr会调整计数值，只拷贝到string的末尾
  + s.substr(pos,n);返回一个string,包含s中从pos开始的n个字符的拷贝。pos的默认值为0，n的默认值为s.size()-pos,即拷贝从pos开始的所有字符

#### 9.5.2 改变string的其他方法
  + 除了接受迭代器的insert和erase版本外，string还提供了接受下标的版本，下标指出了开始删除的位置，或是insert到给定值之前的位置：
    ```cpp
    s.insert(s.size(),5,'!); //在s末尾插入5个感叹号
    s.erase(s.size()-5,5) ;//从s删除最后5个字符
    ```
  + 我们还可以将以空字符结尾的字符数组insert到或assign给一个string:
    ```cpp
    const char *cp="Stately, plump Buck";
    s.assign(cp,7);//s="Stately"
    s.insert(s.size(),cp+7); //s="Stately, plump Buck"
    ```
  + 修改string的操作：
    | 操作 | 含义 |
    | :----- | :----- |
    | s.insert(pos,args) | 在pos之前插入args指定的字符。pos可以是一个下标或是一个迭代器。接受下标的版本返回一个指向s的引用；接受迭代器版本返回指向第一个插入字符的迭代器|
    | s.erase(pos,len) | 删除从位置pos开始的len个字符。如果len被省略，则删除从pos开始直至s末尾的所有字符，返回一个指向s的引用 |
    | s.assign(args) | 将s中的字符替换为args指定的字符，返回一个指向s的引用 |
    | s.append(args) | 将args追加到s.返回一个指向s的引用 |
    | s.replace(range,args) | 删除s中范围range中的字符，替换为args指定的字符。range或者是一个下标和一个长度，或者是一对指向s的迭代器。返回一个指向s的引用|
    
    args可以是下列形式之一：append和assign可以使用所有形式   
    str 不能与s相同，迭代器b和e不能指向s   
    str:字符串str  
    str,pos,len : str从pos开始最多len个字符  
    cp,len: 从cp指向的字符数组的前（最多）len个字符  
    cp:cp指向的以空字符结尾的字符数组  
    n,c:n个字符c  
    b,e:迭代器b和e指定的范围内的字符  
    初始化列表：花括号包围的，以逗号分割的字符列表  
    replace和insert所允许的args形式依赖于range和pos是如何指定  
    | replace | replace | insert | insert | args可以是 |
    | :----- | :----- | :----- | :----- | :----- |
    | (pos,len,args) | (b,e,args) | (pos,args) | (iter,args) | |
    | 是 | 是 | 是 | 否 | str|
    | 是 | 否 | 是 | 否 | str,pos,len |
    | 是 | 是 | 是 | 否 | cp,len |
    | 是 | 是 | 否 | 否 | cp |
    | 是 | 是 | 是 | 是 | n,c |
    | 否 | 是 | 否 | 是 | b2,e2|
    | 否 | 是 | 否 | 是 | 初始化列表 |

#### 9.5.3 string搜索操作
  + 每个搜索操作都返回一个string::size_type值，表示匹配发生位置的下标。如果搜索失败，则返回一个名为string::npos的static成员。标准库将npos定义为一个const string::size_type类型，并初始化为值-1.由于npos是一个unsigned类型，此初始值意味着npos等于任何string最大的可能大大小。用一个int或其他带符号类型来保存这些函数的返回值不是一个好主意
  + string搜索操作：
   | s.find(args) | 查找s中args第一次出现的位置 |
   | s.rfind(args) | 查找s中args最后一次出现的位置 |
   | s.find_first_of(args) | 在s中查找args中任何一个字符第一次出现的位置 |
   | s.find_last_of(args) | 在s中查找args中任何一个字符最后一次出现的位置 |
   | s.find_first_not_of() | 在s中查找第一个不在args中的字符 |
   | s.find_last_not_of() | 在s中查找最后一个不在args中的字符 |
   
   args必须是以下形式之一：   
   c,pos:从s中位置pos开始查找字符c，pos默认为0   
   s2,pos:从s中位置pos开始查找字符串s2,pos默认为0   
   cp,pos:从s中位置pos开始查找指针cp指向的以空字符结尾的C风格字符串。pos默认为0   
   cp,pos,n:从s中位置pos开始查找指针cp指向的数组前n个字符，pos和n无默认值  

#### 9.5.4 compare函数
  + s.compare的几种参数形式（返回的结果是0 整数 负数，也就是调用者-被调用者）：
    | 参数 | 含义 |
    | :----- | :----- |
    | s2 | 比较s和s2 |
    | pos1,n1,s2 | 将s中从pos1开始的n1个字符与s2进行比较 |
    | pos1,n1,s2,pos2,n2 | 将s中从pos1开始的n1个字符与s2中从pos2开始的n2个字符进行比较 |
    | cp | 比较s与cp指向的以空字符结尾的字符数组 |
    | pos1,n1,cp | 将s中从pos1开始的n1个字符与cp指向的以空字符结尾的字符数组进行比较 |
    | pos1,n1,cp,n2 | 将s中从pos1开始的第n1个字符与指针cp指向的地址开始的n2个字符开始比较 |

#### 9.5.5 数值转换
  + 如果string不能转换为一个数值，这些函数抛出一个invalid_argument异常，如果转换得到的数值无法用任何类型来表示，则抛出一个out_of_range异常  
  + string和数值之间的转换：  
    | 操作 | 含义 |
    | :----- | :----- |
    | to_string(val) | 一组重载函数，返回数值val的string表示。val可以是任何算术类型。对每个浮点类型和int或更大整型，都有相应版本to_string。与往常一样，小整形会被提升 |
    | stoi(s,p,b)<br>stol(s,p,b)<br>stoul(s,p,b)<br>stoll(s,p,b)<br>stoull(s,p,b) | 返回s的起始子串（表示整数内容）的数值，返回类型分别是int,long,unsigned long, long long, unsigned long long。b表hi转换所用的基数，默认值为10.p是size_t指针，用来保存s中第一个非数值字符的下标，p默认为0，即函数不保存下标 |
    | stof(s,p)<br>stod(s,p)<br>stold(s,p) | 返回s的起始子串（表示浮点数内容）的数值，返回值类型分别是float，double或long double。参数p的作用与整数转换函数中一样 |

### 9.6 容器适配器
  + 除了顺序容器外，标准库还定义了三个顺序容器适配器：stack,queue和priority_queue。适配器是标准库中的一个通用概念，本质上一个适配器是一种机制，能使某种事物的行为看起来像另外一种事物一样。
  + 所有容器适配器都支持的操作和类型：
    | 操作/类型 | 含义 |
    | :----- | :----- |
    | size_type | 一种类型，足以保存当前类型的最大对象的大小 |
    | value_type | 元素类型 |
    | container_type | 实现适配器的底层容器类型|
    | A a; | 创建一个名为a的空适配器 |
    | A a(c); | 创建一个名为a的适配器，带有容器c的一个拷贝 |
    | 关系运算符 | 每个适配器都支持所有关系运算符：==,!=,<,<=,>,>=,这些运算符返回底层容器的比较结果 |
    | a.empty() | 若a包含任何怨怒是，返回false,否则返回true |
    | a.size() | 返回a中的元素数目 |
    | a.swap(b)<br>swap(a,b) | 交换a和b的内容，a和b必须有相同类型，包括底层容器类型也必须相同|
  + 每个适配器都定义两个构造函数：默认构造函数创建一个对象，接受一个容器的构造函数拷贝该容器来初始化适配器
  + 默认情况下，stack和queue是基于deque实现的，proority_queue是在vector之上实现的。我们在创建一个适配器时将一个命名的顺序容器作为第二个参数类型来重载默认容器类型。
    ```cpp
    //在vector上实现的空栈
    stack<string,vector<string>> str_stk;
    //str_stk2在vector上实现，初始化时保存svec的拷贝
    stack<string, vector<string>> str_stk2(svec);
    ```
  + 对于一个给定的适配器，可以使用哪些容器是有限制的。所有适配器都要求容器具有添加和删除元素的能力。因此，适配器不能构造在array上。同样，也不能使用forward_list，因为所有适配器也要求具有访问尾元素的能力。
  + stack只要求push_back，pop_back和back()操作，因此可以使用除了array和forwarD_list之外的任何容器
  + queue适配器要求back,push_back,front,push_front，因此可以构造于list和deque之上，但不能是vector
  + priority_queue除了fron,push_back,pop_back外，换要求随机访问能力，因此构造与vector和deque上
  + 未列出的栈操作（栈默认基于deque实现，也可以在list和vector上实现）：
    | 操作 | 含义 |
    | :----- |:----- |
    | s.pop() | 删除栈顶元素，但不返回该元素值 |
    | s.push(item)<br>s.emplace(args) | 创建一个新元素压入栈顶，该元素通过拷贝或移动item而来，或者由args构造 |
    | s.top() | 返回栈顶元素，但不将元素弹出栈 |
  + 每个容器适配器都基于底层容器类型的操作定义了自己的特殊操作。我们只可以使用适配器操作，而不能使用底层容器类型的操作
  + 未列出的queue和priority_queue操作：
    | 操作 | 含义 |
    | q.pop() | 删除queue的首元素或priority_queue的最高优先级的元素，但不返回此元素 |
    | q.front()<br>q.back() | 返回首元素或尾元素，但不删除此元素,只适用于queue |
    | q.top() | 返回最高优先级元素，但不删除该元素 只适用于priority_queue |
    | q.push(item)<br>q.emplace(args) | 在queue末尾或priority_queue中恰当位置创建一个元素，其值为item或者由args构造|
  + 默认情况下，标准库在元素类型上使用\<运算符来确定相对优先级



