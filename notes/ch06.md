## 第六章 函数
### 6.1 函数基础
  + 函数组成部分：返回类型、函数名字、由0个或多个形参组成的列表、函数体。通过调用运算符()来执行函数，该表达式是函数或者指向函数的指针。
  + 函数的调用完成两项工作：用实参初始化函数对应的形参；将控制权转移给被调用函数。此时主调函数的执行被暂时中断，被调函数开始执行。
  + 实参是形参的初始值，但是没有规定实参的求值顺序，编译器可能以任意可行的顺序对实参求值。
  + 函数的形参列表可以为空，但是不能省略，要想定义一个不带形参的函数，最常用的办法是书写一个空的形参列表，不过为了与C语言兼容，也可以使用关键字void表示函数没有形参
  + 一种特殊的返回类型是void，表示函数不反悔任何值。函数的返回类型不能是数组类型或函数类型，但可以是指向数据或函数的指针。

#### 6.1.1局部对象
  + 名字存在作用域，对象有生命周期。名字的作用域是程序文本的一部分，名字在其中可见。对象的生命周期是程序执行过程中该对象存在的一段实践。
  + 形参和函数体内部定义的变量统称为局部变量。局部变量会隐藏外层作用域中同名的其他所有声明。
  + 自动对象：只存在于块执行期间的对象。形参是一种自动对象
  + 某些时候，有必要令局部变量的生命周期贯穿函数调用及之后的时间，可以将局部变量定义成static类型从而获得这样的对象。局部静态对象在程序的执行路径第一次经过对象定义语句时初始化，并且直到程序终止才被销毁，在此期间即使对象所在函数结束执行也不会对它有所影响。

#### 6.1.2 函数声明
  + 函数的名必须在使用之前声明，函数只能定义一次，但是可以声明多次。如果一个函数永远也不会被我们用到，那么它可以只有声明没有定义。
  + 因为函数的声明不包含函数体，所以也就无须形参的名字，在函数声明中常常忽略形参的名字，但是加上也是有用的，可以帮助使用者更好的理解函数的意义。
  + 变量和函数都应该在头文件中声明，在源文件中定义。
  + 定义函数的源文件应该把含有函数声明的头文件包含进来，编译器负责验证函数的定义和声明是否匹配。

#### 6.1.3 分离式编译
  + 分离式遍历允许我们把程序分割到几个文件中去，每个文件独立编译。如果我们修改了其中一个源文件，那么只需要重新编译那个改动了的文件。

### 6.2 参数传递
  + 如果形参是引用类型，它将绑定到对应的实参上；否则，将实参的值拷贝后赋值给形参。 
  + 形参是引用类型的时候，我们说其对应的实参被引用传递或者函数被传引用调用。当实参的值拷贝给形参时，形参和实参是两个是两个相互独立的对象，我们说这样的实参被值传递，或者函数被传值调用。

#### 6.2.1 传值参数
  + C程序员常常使用指针类型的形参访问函数外部的对象,在C++中建议使用引用类型的形参替代指针。

#### 6.2.2 传引用参数
  + 拷贝大的类类型对象或者容器对象比较低效，甚至有的类类型（包括IO类型在内）根本就不支持拷贝操作。当某种类型不支持拷贝操作时，函数只能通过引用形参访问该类型的对象。例如string对象可能会比较长，我们应该尽量避免直接拷贝它们，这时使用引用形参是比较明智的选择。如果函数无须改变引用形参的值，最好将其声明为常量引用。
  + 一个函数只能返回一个值，然后有时候函数需要同时返回多个值，引用形参为我们一次返回多个结果提供了有效的途径，可以给函数传入一个额外的引用实参，令其保存我们需要的返回内容。  

#### 6.2.3 const形参和实参  
  + 当实参是顶层const，传值给形参的时候会忽略其顶层const。当形参有顶层const时，传给它常量对象或者非常量对象都是可以的。  
  + 尽量使用常量引用。把函数不会改变的形参定义成（普通的）引用是一种比较常见的错误，这么做带给函数的调用者一种误导，即函数可以修改它的实参的值。  

#### 6.2.4 数组形参
  + 不允许拷贝数组，使用数组时通常会将其转换成指针。以数组作为形参的函数必须确保使用数组时不会越界。  
  + 管理指针形参的三种常用的技术：
    + 要求数组本身包含一个结束标志，例如C风格字符串
    + 传递指向数组首元素和尾后元素的指针。  
    + 专门定义一个表示数组大小的形参  
  + `int &arr[10]`将arr声明成了引用的数组；`int (&arr)[10]`arr是具有十个整数的整型数组的引用。  
  + 多维数组其实是数组的数组，当将多维数组传递给函数时，实际上真正传递的是指向数组首元素的指针。因为我们处理的是数组的数组，所以首元素本身就是一个数组，指针就是一个指向数组的指针。数组第二维（以及后面的所有维度）的大小都是数组类型的一部分，不能忽略。



