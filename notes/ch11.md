## 第十一章 关联容器
  + 关联容器支持高效的关键字查找和访问，两个主要的关联容器类型是map和set
  + map中的元素是一些关键字-值对，关键字起到索引的作用，值则表示与索引相关联的数据
  + set中每个元素只包含一个关键字，set支持高效的关键字查询操作——检查一个给定关键字是否在set中
  + 标准库提供了8个关联容器，其不同体现在三个维度上：
    + 或者是一个set,或者是一个map
    + 或者要求不重复的关键字，或者允许重复关键字
    + 按顺序保存元素，或无序保存
  + 允许重复的容器的名字中都包含单词multi；不保持关键字按顺序存储的容器的名字都以单词unordered开头
  + 无序容器使用哈希函数来组织元素
  + 类型map和multimap定义在头文件map中；set和multiset定义在头文件set中；无序容器则定义在头文件unordered_map和unordered_set中
  + 关联容器类型：
    | 类型 | 含义 |
    | map | 关联数组，保存关键字-值对，有序 |
    | set | 关键字即值，有序 |
    | multimap | 关键字可重复出现的map |
    | multiset | 关键字可重复出现的set |
    | unordered_map | 用哈希函数组织的map |
    | unordered_set | 用哈希函数阻止的set |
    | unordered_multimap | 哈希组织的map;关键字可重复出现 |
    | unordered_multiset | 哈希组织的set；关键字可重复出现 |

### 11.1 使用关联容器
  + map类型通常被称为关联数组，与正常数组不同的是，其下标不必是整数
  + 为了定义一个map，我们必须指定关键字和值的类型
  + 如果word未在关键字中，则m\[word\]会创建一个关键字-值对
  + 从map中提取一个元素时，会得到一个pair类型的对象。
  + 可以对一个关联容器进行列表初始化

### 11.2 关联容器概述
  + 关联容器不支持顺序容器位置相关的操作，例如push_back,push_front等，原因是关联容器中元素是根据关键字存储的，关键容器也不支持构造函数或插入操作这些接受一个元素值和一个数量值的操作
  + 关联容器的迭代都是双向的

#### 11.2.1 定义关联容器
  + 当初始化一个map时，必须提供关键字类型和值类型，我们将每个关键字-值对包围在花括号中：`{key,value}`

#### 11.2.2 关键字类型的要求
  + 对于有序容器——map,multimap,set,multiset关键字类型必须定义元素比较的方法，默认情况下，标准库使用关键字类型的\<运算符来比较两个关键字
  + 可以向一个算法提供我们自己定义的比较操作，也可以提供自己的操作来代替关键字上的\<运算符，所提供的操作必须在关键字类型上定义一个严格弱序：
    + 两个关键字不能同时“小于等于”对方
    + 如果k1小于等于k2,k2小于等于k3，则k1小于等于k3
    + 如果存在两个关键字，任何一个都不小于等于另一个，那么称这两个关键字是等价的，如果k1等价k2,k2等价k3，则k1等价k3
  + 用来组织一个容器中元素的操作的类型也是该容器类型的一部分，为了指定使用自定义的操作，必须在定义关联容器类型时提供此操作的类型`multiset<Sales_data,decltype(compareIsbn)*> boolstore(compareIsbn);`,当用decltype来获得一个函数指针类型时，必须加上一个\*来指出我们要使用一个给定函数类型的指针

#### 11.2.3 pair类型
  + 一个pair保存两个数据成员，必须提供两个类型名
  + pair上的操作：
    | 操作 | 含义 |
    | :----- | :----- |
    | pair<T1,T2> p; | p是一个pair，两个类型分别为T1和T2的成员都进行了值初始化 |
    | pair<T1,T2>p(v1,v2) | p是一个成员类型为T1和T2的pair，first和second成员分别用v1和v2进行初始化 |
    | pair<T1,T2>p={v1,v2} | 等价于p(v1,v2) |
    | make_pair(v1,v2) | 返回一个用v1和v2初始化的pair，pair的类型从v1,v2的类型推断出来的 |
    | p.first | 返回p的名为first的（公有）数据成员 |
    | p.second | 返回p的名为second的（公有）数据成员 |
    | p1 relop p2 | 关系运算符(\<,>,<=,>=)按字典序定义，例如。当p1.first<p2.first或!(p1.first<p2.first)&&p1.second<p2.second成立时，p1<p2为true，关系运算符利用<运算符来实现 |
    | p1 == p2<br>p1 != p2 | 当first和second成员分别相等时，两个pair相等，相等性判断利用元素的==运算符实现 |

### 11.3 关联容器操作
  + 关联容器额外的类型别名：
    | 类型别名 | 含义 |
    | :----- | :----- |
    | key_type | 此容器类型的关键字类型 |
    | mapped_type | 每个关键字关联的类型：只适用于map |
    | value_type | 对于set，与key_type相同；对于map,为pair<const key_type,mapped_type> |

#### 11.3.1 关联容器迭代器
  + 当解引用一个关联容器迭代器时，我们会得到一个类型为容器的value_type的值的引用
  + 迭代器不能改变一个map元素的关键字，也不能改变set中的关键字
  + 当使用一个而迭代器遍历一个map,multimap,set或multiset时，迭代器按关键字升序遍历元素
  + 关联容器可用于只读取元素的算法，因为关联容器的关键字都是const，不适用于可写算法
  + 使用关联容器定义的专用find成员会比调用泛型find快得多
  + 在实际编程中，如果我们真要对一个关联容器使用算法，要么是将它当作一个源序列，要么当作一个目的位置


