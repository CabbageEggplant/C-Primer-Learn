## 第十二章 动态内存

+ 静态内存用来保存局部static对象、类static数据成员以及定义在任何函数之外的变量
+ 栈内存用来保存定义在函数内的非static对象。
+ 分配在静态或栈内存的对象由编译器自动创建和销毁。对于栈对象，仅在定义的程序块运行时才存在；static对象在使用之前分配，在程序结束时销毁
+ 除了静态内存和栈内存，每个程序还拥有一个内存池，被称为自由空间或堆，存储动态分配的对象。动态对象的生存期由程序来控制，也就是说，当动态对象不再使用时，我们的代码必须显式地销毁它们

### 12.1 动态内存与智能指针

+ new在动态内存中为对象分配空间并返回一个指向该对象的指针，我们可以选择对对象进行初始化；delete接受一个动态对象的指针，销毁该对象，并释放与之关联的内存

+ 有时我们会忘记释放内存，在这种情况下就会产生内存泄漏，有时在尚有指针引用内存的情况下我们就释放了它，在这种情况下就会产生引用非法内存的指针

+ C++11标准提供了两种智能指针类型来管理动态对象。智能指针的行为类似常规指针，重要的区别是它负责自动释放所指向的对象

+ 两种智能指针的区别在于管理底层指针的方式：shared_ptr允许多个指针指向同一个对象；unique_ptr则独占所指向的对象

+ 标准库还定义了一个名为weak_ptr的伴随类，它是一种弱引用，指向shared_ptr所管理的对象。这三种类型都定义在memory中

#### 12.1.1shared_ptr类

+ 默认初始化的智能指针中保存着一个空指针

+ shared_ptr和unique_ptr都支持的操作：

  | 操作                                   | 含义                                                         |
  | -------------------------------------- | ------------------------------------------------------------ |
  | share_ptr<T> sp;<br />unique_ptr<T>up; | 空智能指针，可以指向类型为T的对象                            |
  | p                                      | 将p作为一个条件判断，若p指向一个对象，则为true               |
  | *p                                     | 解引用p,获得它指向的对象                                     |
  | p->mem                                 | 等价于(*p).mem                                               |
  | p.get()                                | 返回p中保存的指针。要小心使用，若智能指针释放了其对象，返回的指针所指向的对象也就消失了 |
  | swap(p,q)<br />p.swap(q)               | 交换p和q中的指针                                             |

+ shared_ptr独有的操作：

  | 操作                 | 含义                                                         |
  | -------------------- | ------------------------------------------------------------ |
  | make_shared<T>(args) | 返回一个shared_ptr,指向一个动态分配的类型为T的对象，使用args初始化此对象 |
  | shared_ptr<T>p(q)    | p必须是shared_ptr的拷贝，此操作会递增q中的计数器。q中的指针必须能转换为T* |
  | p=q                  | p和q都是shared_ptr,所保存的指针必须能相互转换，此操作会递减p的引用计数，递增q的引用计数；若p的引用计数变为0，则将其管理的原内存释放 |
  | p.unique()           | 若p.use_count()为1，返回true,否则返回false                   |
  | p.use_count()        | 返回与p共享对象的智能指针数量；可能很慢，主要用于调试        |

+ 最安全的分配和使用动态内存的方法是调用make_shared的标准库函数`shared_ptr<int>p=make_shared<int>(42);`

+ 当进行拷贝或赋值操作的时候，每个shared_ptr都会记录有多少个其他shared_ptr指向相同的对象

+ 当指向一个对象的最后一个shared_ptr被销毁时，shared_ptr类会自动销毁此对象，通过一个析构函数完成销毁

+ 如果将shared_ptr存放于一个容器中，而后不再需要全部元素，而只使用其中一部分，要记得用erase删除不再需要的哪些元素

+ 程序使用动态内存的原因：

  + 程序不知道自己需要使用多少对象
  + 程序不知道所需对象的准确类型
  + 程序需要在多个对象间共享数据

+ 如果两个对象共享底层的数据，当某个对象被销毁时，我们不能单方面地销毁底层数据



#### 12.1.2 直接管理内存

+ 默认情况下，动态分配的对象是默认初始化的，这意味着内置类型或组合类型的对象的值将是未定义的，而类类型对象将用默认构造函数进行初始化。

+ 也可以对动态分配的对象进行值初始化，只需要在类型名之后跟一对空括号即可。

  ```cpp
  string *ps1=new string;//默认初始化未空string
  string *ps=new string();//值初始化为空string
  int *pi1=new int;//默认初始化，*pi1的值未定义
  int *pi2=new int();//值初始化为0，*pi2为0
  ```

+ 对于定义了自己的构造函数的类类型（例如string）来说，要求值初始化是没有意义的。不管采用什么形式，对象都会通过默认构造函数来初始化。但对于内置类型，两种形式差别比较大，值初始化的内置类型对象有着良好定义的值，而默认初始化的对象的值则是未定义的。同理，对于类中哪些依赖于编译器合成的默认构造函数的内置类型成员，如果它们未在类内被初始化，那么它们的值也是未定义的

+ 如果我们提供了一个括号包围的初始化器，就可以使用auto从此初始化器中推断我们想要分配的对象的类型

  ```cpp
  auto p1=new auto(obj);
  auto p2= new auto{a,b,c};//错误，括号中智能有单个初始化器
  ```

+ 默认情况下，如果new不能分配所要求的内存空间，它会抛出一个类型为bad_alloc的异常，可以改变使用new的方式来阻止它抛出异常

  ```cpp
  int *p1 = new int; //如果分配失败，new抛出std::bad_alloc
  int *p2 = new (nothrow) int; //如果分配失败，new返回一个空指针
  ```

  第二种形式是定位new，允许我们向new传递额外的参数

+ delete执行两个动作，销毁给定的指针指向的对象；释放对应的内存

+ 传递给delete的指针必须指向动态分配的内存，或者是一个空指针。释放一块并非new分配的内存，或者将相同的指针释放多次，其行为是未定义的

+ 返回指向动态内存的指针（而不是智能指针）的函数给其调用者增加了一个额外负担——调用者必须记得释放内存

+ 使用new和delete管理动态内存存在三个常见问题：

  + 忘记delete内存
  + 使用已经释放掉的对象
  + 同一块内存释放多次

+ delete之后应该重置指针值，delete之后，指针就变成了人们所说的空悬指针，即指向一块曾经保存数据对象但现在已经无效的内存的指针

#### 12.1.3 shared_ptr和new结合使用

+ 可以用new返回的指针初始化智能指针 `shared_ptr<int> p2(new int(42));`，接受指针参数的只能指针式explicit的，因此不能将一个内置指针隐式地转换为一个智能指针，必须使用初始化的方式

+ 默认情况下，一个用来初始化智能指针的普通指针必须指向动态内存，因为智能指针默认使用delete释放它所关联的对象。我们可以将智能指针绑定到一个指向其他类型的资源的指针上，但是为了这么做，必须提供自己的操作来代替delete

+ 定义和改变shared_ptr的其他方法：

  | 操作                                        | 含义                                                         |
  | ------------------------------------------- | ------------------------------------------------------------ |
  | shared_ptr<T> p(q);                         | p管理内置指针q所指向的对象，q必须指向new分配的内存，且能够转换为T*类型 |
  | shared_ptr<T>p(u);                          | p从unique_ptr u那里接管了对象的所有权，将u置为空             |
  | shared_ptr<T>p(q,d)                         | p接管了内置指针q所指向的对象的所有权，q必须能转换为T*类型，p将使用可调用对象d来代替delete |
  | shared_ptr<T> p(p2,d)                       | p是shared_ptr p2的拷贝，唯一的区别是p将用可调用对象d来代替delete |
  | p.reset()<br />p.reset(q)<br />p.reset(q,d) | 若p是唯一指向其对象的shared_ptr,reset会释放此对象。若传递了可选用的参数内置指针q,会令p指向q,否则将p置为空。若还传递了参数d,将会调用d而不是delete来释放q |

+ 不要混合使用普通指针和智能指针

  ```cpp
  int *x(new int(1024));
  process(shared_ptr(shared_ptr<int>(x)));
  int j = *x;//未定义的，x是一个空悬指针
  ```

  当process这个调用所在表示式结束时，这个临时对象就销毁了。销毁这个临时变量会递减引用计数，此时引用计数就变为了0，因此，当临时对象被销毁时，它所指向的内存会被释放

+ 使用一个内置指针来访问一个智能指针多负责的对象时很危险的，因为我们无法知道对象何时会被销毁

+ 不要使用get初始化另一个智能指针或为智能指针赋值，此时两个智能指针相互独立

+ get是为了 需要向不能使用智能指针的代码传递一个内置指针。使用get返回的指针的代码不能delete此指针



### 12.1.4 智能指针和异常

+ 一个简单的确保资源被释放的方法是使用智能指针

+ 删除器函数必须能够完成对shared_ptr中保存的指针进行释放的操作

  ```cpp
  void end_connection(connection *p){disconnect(p);}
  connection c = connect(&d);
  shared_ptr<connect>p(&c,end_connection);
  ```

+ 为了正确使用智能指针，必须坚持一些基本规范：

  + 不使用相同的内置指针值初始化（或reset）多个智能指针
  + 不delete get()返回的指针
  + 不使用get()初始化或reset另一个智能指针
  + 如果你使用get()返回的智能指针，记住当最后一个对应的智能指针销毁后，你的指针就变为无效了
  + 如果你使用智能指针管理的资源不是new分配的内存，记住传递给它一个删除器

#### 12.1.5 unique_ptr

+ 当我们定义一个unique_ptr时，需要将其绑定到一个new返回的指针上，由于一个unique_ptr拥有它所指向的对象，因此unique_ptr不支持普通的拷贝或赋值操作

+ unique_ptr操作：

  | 操作                                      | 含义                                                         |
  | ----------------------------------------- | ------------------------------------------------------------ |
  | unique_ptr<T> u1;<br />unique_ptr<T,D>u2; | 空unique_ptr，可以指向类型为T的对象，u1使用delete来释放它的指针；u2使用一个类型为D的可调用对象来释放它的指针 |
  | unique_ptr<T,D> u(d);                     | 空unique_ptr,指向类型为T的对象，用类型为D的对象d代替delete   |
  | u = nullptr                               | 释放u指向的对象，将u置为空                                   |
  | u.release()                               | u放弃对指针的控制权，返回指针，并将u置为空                   |
  | u.reset()                                 | 释放u所指向的对象。                                          |
  | u.reset(q)<br />u.reset(nullptr)          | 如果提供了内置指针q,令u指向这个对象，否则将u置为空           |

+ 虽然不能拷贝或赋值unique_ptr,但可以通过调用release或reset将指针的所有权从一个（非const）unique_ptr转移给另一个unique_ptr:

  ```cpp
  unique_ptr<string> p2(p1.release());
  p3.reset(p4.release());
  ```

+ 如果不用另一个智能指针来保存release返回的指针，我们的程序就要负责资源的释放：

  ```cpp
  p2.release(); //错误，p2不会释放内存，而且我们丢失了指针
  auto p = p2.release();//正确，但是我们必须记得delete p
  ```

+ 不能拷贝unique_ptr的规则有一个例外，我们可以拷贝或赋值一个将要被销毁的unique_ptr,最常见的例子就是从函数返回一个unique_ptr

+ 重载一个unique_ptr中的删除器会影响到unique_ptr类型以及如何构造（或reset）该类型的对象，与重载关联容器的比较操作类似，我们必须在尖括号中unique_ptr指向类型之后提供删除器类型

#### 12.1.6 weak_ptr

+ weak_ptr是一种不控制所指向对象生存期的智能指针，它指向一个由shared_ptr管理的对象。将一个weak_ptr绑定到一个shared_ptr不会改变shared_ptr的计数。一旦最后一个指向对象的shared_ptr被销毁，对象就会被释放。即使有weak_ptr指向对象，对象也还是会被释放

+ weak_ptr操作：

  | 操作              | 含义                                                         |
  | ----------------- | ------------------------------------------------------------ |
  | weak_ptr<T> w     | 空weak_ptr,可以指向类型为T的对象                             |
  | weak_ptr<T> w(sp) | 与shared_ptr sp指向相同对象的weak_ptr.T必须能转换为sp指向的类型 |
  | w = p;            | p可以是一个shared_ptr或一个weak_ptr,赋值后w与p共享对象       |
  | w.reset()         | 将w置为空                                                    |
  | w.use_count()     | 与w共享对象的shared_ptr的数量                                |
  | w.expired()       | 若w.use_count()为，返回true,否则返回false                    |
  | w.lock()          | 如果expired为true,返回一个空shared_ptr，否则返回一个指向w的对象的shared_ptr |

+ 由于对象可能不存在，我们不能使用weak_ptr直接访问对象，而必须调用lock


### 12.2 动态数组

+ c++11定义了另一种new表达式语法，可以分配并初始化一个对象数组。标准库中包含一个名为allocator的类，允许我们将分配和初始化分离

#### 12.2.1 new和数组

+ 为了让new分配一个对象数组，我们要在类型名之后跟一对方括号，在其中指明要分配的对象的数目

+ new分配数组返回的也是一个元素类型的指针，因为其不是一个数组类型，因此不能对动态数组调用begin和end

+ 默认情况下，new分配的对象，不管是单个分配的还是数组中的，都是默认初始化的，可以对数组中的元素进行值初始化，方法是在大小之后跟一对空括号，还可以将空括号还未一个元素初始化器的花括号列表

+ 虽然不能创建一个大小为0的静态数组对象，但当n等于的时候，调用new[n]是合法，只是不能对其返回的指针进行解引用

+ 对于零长度的指针来说，此指针就像尾后指针一样，可以像使用尾后迭代器一样使用这个指针，可以向此指针加上（或减去）0，也可以从此指针减去自身而得到0

+ 为了释放动态数组，在指针前加上一个空方括号`delete []p`,数组中的元素按逆序销毁

+ 如果我们在delete一个数组指针时忘记了方括号，或者在delete一个单一对象的指针时使用了方括号，编译器很可能不会给出警告。我们的程序可能在执行过程中在没有任何警告的情况下行为异常

+ 标准库提供了一个可以管理new分配的数组的unique_ptr版本。

  ```cpp
  unique_ptr<int[]> up(new int[10]);
  up.release(); //自动用delete[]销毁其指针
  ```

+ 指向数组的unique_ptr:

  + 指向数组的unique_ptr不支持成员访问运算符（点和箭头运算符）
  + 其他unique_ptr操作不变

  | 操作                 | 含义                                                      |
  | -------------------- | --------------------------------------------------------- |
  | unique_ptr<T[]>u     | u可以指向一个动态分配的数组，数组元素类型为T              |
  | unique_ptr<T[]> u(p) | u指向内置指针p所指向的动态分配的数组，p必须能转换为类型T* |
  | u[i]                 | 返回u所拥有的数组中的位置i处的对象，u必须指向一个数组     |

+ 与unique_ptr不同，shared_ptr不直接支持管理动态数组，如果希望使用shared_ptr管理一个动态数组，必须提供自己定义的删除器

  ```cpp
  shared_ptr<int> sp(new int[10],[](int *p){delete []p;});
  sp.reset();//使用我们提供的lambda释放数组，它使用delete []p
  ```

+ shared_ptr不直接支持动态数组管理这一特性会影响我们如何访问数组中的元素：

  ```cpp
  for(size_t i = 0; i != 10; ++i)
      *(sp.get() + i) = i;
  ```

  shared_ptr未定义下标运算符，而且智能指针类型不支持指针算术运算，因此为了访问数组中的元素，必须用get获取一个内置指针，然后用它来访问数组元素

#### 12.2.2 allocator类

+ new有一些灵活性上的局限，其中一方面表现在它将内存分配和对象构造函数组合在了一起，类似delete将对象析构和内存释放组合在了一起。我们分配单个对象时通常希望将内存分配和对象构造分离。因为在这种情况下，我们几乎肯定可以知道对象应该有什么值

+ 当分配一大块内存时，我们通常计划在这块内存上按需构造对象。在此情况下，我们希望将内存分配和对象构造分离。这意味着我们可以分配大块内存，但只在真正需要时才真正执行对象创建操作（同时付出一定开销）

+ 一般情况下，将内存分配和对象构造组合在一起可能会导致不必要的浪费

+ 更重要的是，哪些没有默认构造函数的类就不能动态分配数组了

+ 标准库allocator类定义在头文件memory中，它帮助我们将内存分配和对象构造分离开来。它提供一种类型感知的内存分配方法，它分配的内存是原始的、未构造的。

+ 标准库allocator类及其算法：

  | 操作                | 含义                                                         |
  | ------------------- | ------------------------------------------------------------ |
  | allocator<T>a       | 定义了一个名为a的allocator对象，它可以为类型为T的对象分配内存 |
  | a.allocate(n)       | 分配一段原始的，未构造的内存，保存n个类型为T的对象           |
  | a.deallocate(p,n)   | 释放从T*指针p开始的内存，这块内存保存了n个类型为T的对象。p必须是一个先前由allocate返回的指针，且n必须是p创建时所要求的大小。在调用deallocate之前，用户必须对每个在这块内存中创建的对象调用destory |
  | a.construct(p,args) | p必须是一个类型为T*的指针，指向一块原始内存。args被传递给类型为T的构造函数，用来在p指向的内存中构造一个对象 |
  | a.destroy(p)        | p为T*类型的指针，此算法对p指向的对象执行析构函数             |

+ 还未构造对象的情况下就使用原始内存是错误的

+ 只能对真正构造了的元素进行destroy操作

+ 一旦元素被销毁后，就可以重新使用这部分内存来保存其他string,也可以将其归还给系统

+ 标准库未allocator类定义了两个伴随算法，可以在未初始化内存中创建对象，定义在头文件memory中（这些函数在给定目的位置创建元素，而不是由系统分配内存给它们）：

  | 操作                         | 含义                                                         |
  | ---------------------------- | ------------------------------------------------------------ |
  | uninitialized_copy(b,e,b2)   | 从迭代器b和e指出的输入范围中拷贝元素到迭代器b2指定的未构造的原始内存中。b2指向的内存必须足够大，能够容纳输入序列中元素的拷贝 |
  | uninitialized_copy_n(b,n,b2) | 从迭代器b指向的元素开始，拷贝n个元素到b2开始的内存中         |
  | uninitialized_fill(b,e,t)    | 在迭代器b和e指定的原始内存范围中创建对象，对象的值均为t的拷贝 |
  | uninitialized_fill_n(b,n,t)  | 从迭代器b指向的内存地址开始创建n个对象，b必须指向足够大的未构造的原始内存，能够容纳给定数量的对象 |

+ 上述函数会返回一个指针，指向最后一个构造元素之后的位置

### 12.3 使用标准库：文本查询程序

#### 12.3.1 文本查询程序设计

+ 开始一个程序的设计的一种好办法是列出程序的操作

#### 12.3.2 文本查询程序类的定义

