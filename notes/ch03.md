## 第三章 字符串、向量和数组
### 3.1 命名空间using声明
  + using声明，每个using声明引入命名空间的一个成员`using std::cin;`  
  + 位于头文件的代码一般不应该使用using声明，因为头文件的内容会拷贝到所有引用它的文件中去，如果头文件里面有某个using声明，那么每个使用了该头文件的文件都会有这个声明，对于某些程序来说，由于不经意间包含了一些名字，反而可能产生始料未及的名字冲突。

### 3.2 标准库类型string
  + 标准库类型string表示可变长的字符序列，包含在头文件string中，string定义在命名空间std中。
    ```cpp
    #include <string>
    using std::string;
    ```
#### 3.2.1 定义和初始化string对象
  + 初始化string对象的方式：
    | 方式 | 含义 |
    | :----- | :----- |
    | string s1 | 默认初始化，s1是一个空串 |
    | string s2(s1) | s2是s1的副本 | 
    | string s2 = s1 | 等价于string s2(s1),s2是s1的副本 |
    | string s3("value") | s3是字面值"value"的副本，除了字面值最后的那个空字符外 |
    | string s3 = "value" | 等价于s3("value")，s3是字面值"value"的副本 |
    | string s4 = (n,'c') | 把s4初始化为由连续n个字符c组成的串 |
    
  + 拷贝初始化，使用等号初始化一个变量，编译器把等号右侧的初始值拷贝到新建的对象中去。直接初始化，不使用等号。

#### 3.2.2 string对象上的操作
  + string的操作：
    | 操作 | 含义 |
    | :----- | :----- |
    | os<<s | 将s写入到输出流os当中，返回os |
    | is>>s | 从is中读取字符串赋给s，字符串以空白分隔，返回is |
    | getline(is, s) | 从is中读取一行赋给s，返回is | 
    | s.empty() | s为空返回true,否则返回false | 
    | s.size() | 返回s中字符的个数 | 
    | s[n] | 返回s中第n个字符的引用，位置n从0计起 |
    | s1+s2 | 返回s1和s2连接后的结果 |
    | s1=s2 | 用s2的副本代替s1中原来的字符串 |
    | s1==s2 | 如果s1和s2中所包含的字符完全一样，则返回true |
    | s2!=s2 | 如果s1和s2中所包含的字符不完全一样，则返回false | 
    | <,<=,>,>= | 利用字符在字典中的顺序进行比较 |
  + 使用cin>>string对象会自动忽略开头的空白（空格符、换行符、制表符等）并从第一个真正的字符开始读取，直到遇到下一处空白为止。读取未知数量的string对象：
    ```cpp
    while(cin>>str)
      statement;
    ```
  + 使用getline读取一整行，保留其中的空白符，两个参数是输入流和string对象，函数从给定的输入流中读取字符，直到遇到换行符，string中不保存换行符，可能会读取到空字符串（当直接遇到换行符的时候），并且可以用这个函数作为while的条件表达式，直到读取到文件结尾为止。
  + string.empty()返回的是一个string::size_type类型，是一个无符号类型的值，并且足够存放下任何string对象的大小，如果一条表达式中已经有了size()函数就不要再使用int，否则可能会导致出错，使用`auto len = s.size();` 获取字符串大小并且类型也保持一致。
  + 比较字符串大小：
    + 如果两个string对象的长度不同，而且较短的string对象的每个字符都与较长的string对象对应位置上的字符相同，就说较短的string对象小于较长string对象。
    + 如果两个string对象在某些对应的为止不一致，则string对象比较的结果是string对象中第一对相异字符比较的结果。  
  + 字面值和string对象相加，必须保证每个加法运算符（+）的两侧运算对象至少有一个是string:
    ```cpp
    string s6 = s1 + ", " + "world"; //正确
    stirng s7 = "hello" + ", " + s2; //错误
    ```
    s1 + ", "的结果是一个string对象，同时作为第二个加法运算符的左侧运算对象，因此正确。"hello" + ", "是错误的，因为试图将两个字面值加在一起。  
  + C++中的字符串字面值并不是标准库类型string的对象，二者是不同的类型。
#### 3.2.3 处理string对象中的字符
  + cctype头文件中定义的对字符的操作:
     | 函数 | 含义 |
     | :----- | :----- |
     | isalnum(c) | 当c是字母或数字的时候为真 |
     | isalpha(c) | 当c是字母的时候为真 |
     | iscntrl(c) | 当c是控制字符时为真 |
     | isdigit(c) | 当c是数字时为真 |
     | isgraph(c) | 当c不是空格且可打印时为真 |
     | islower(c) | 当c是小写字母时为真 |
     | isprint(c) | 当c是可打印字符时为真 |
     | ispunct(c) | 当c是标点符号时为真 |
     | isspace(c) | 当c是空白时为真（空格、横向制表符、纵向制表符、回车符、换行符、进纸符） | 
     | isupper(c) | 当c是大写字母时为真 |
     | isxdigit(c) | 当c是十六进制数字时为真 | 
     | tolower(c) | 如果c是大写字母，输出对应的小写字母，否则原样输出c |
     | toupper(c) | 如果c是小写字母，输出对应的大写字母，否则原样输出c |
  + 使用范围for语句遍历每个字符。
    ```cpp
      for(declaration: expression)
        statement
      
      for(auto c : str)
        cout<<c<<endl;
    ```
  + 如果要使用范围for语句改变string中的值，必须把循环变量定义成引用类型，因为只有定义成了引用才能让循环变量每次绑定到对应的字符，才能对原字符串继续宁修改。
    ```cpp
    for(auto &c : s)
      c = toupper(c)
    ```
  + 可以通过下标访问，str[n]访问第n+1个字符，返回的是该位置上的引用。如果是空字符串使用下标访问一定不在正常的索引范围内，会引发不可预知的后果。只要字符串不是常量就能为下标运算符返回的字符赋予新值。

### 3.3标准库类型vector
  + 标准库类型vector表示的是对象的集合，也被称为容器，因为其可以容纳其他对象。 
    ```cpp
		#include <vector>
		using std::vector;
		```
  + vector能容纳绝大多数类型的对象作为其元素，但是因为引用不是对象，所以不存在包含引用的vector

#### 3.3.1 定义和初始化vector对象
  + 初始化vector对象的方法：  
     | 方法 | 含义 |
     | :----- | :----- |
     | vector/<T/> v1 | v1是一个空vector，它潜在的元素是T类型的，执行默认初始化 |
     | vector/<T/> v2(v1) | v2中包含v1所有元素的副本 |
     | vector/<T/> v2=v1 | 等价于v2(v1),v2中包含v1所有元素的副本 |
     | vector/<T/> v3(n,val) | v3中包含了n个重复的元素，每个元素的值都是val |
     | vecotr/<T/> v4(n) | v4中包含了n个重复地执行了值初始化的对象 |
     | vector/<T/> v5{a,b,c...} | v5包含了初始化值元素的个数，每个元素被赋予相应的初始值 |
     | vector/<T/> v5={a,b,c...} | 等价于v5{a,b,c...} |
 

#### 3.3.2 向vector对象中添加元素
  + 对于vector对象，直接初始化方法适用于三种情况：
    + 初始值已知且数量较少
    + 初始值是另一个vector对象的副本
    + 所有元素的初始值都一样
  + `vector.push_back(value)` 向vector对象末尾添加一个元素，vector对象可以实现高速添加元素。
  + 如果循环体内部包含有向vector对象添加元素的语句，则不能使用范围for循环。  

#### 3.3.3 其他vector操作
  + vector支持的操作：  
    | 方法 | 含义 |  
    | :----- | :----- |
    | v.empty() | 如果v中不含有任何元素，返回真；否则返回假 | 
    | v.size() | 返回v中元素的个数 |
    | v.push_back(t) | 向v的末端添加一个值为t的元素 |
    | v[n] | 返回v中第n个位置上的引用（从0开始） |
    | v1=v2 | 用v2的元素拷贝替换v1中的元素 |
    | v1={a,b,c...} | 用列表中的元素拷贝替换v1中的元素 |
    | v1==v2 | v1和v2相等当且仅当元素数量相同且对应位置的元素值都相同 |
    | v1!= v2 | v1不等于v2返回true,否则返回false |
    | <,<=,>,>= | 以字典顺序进行比较 |
  
  + v.size()返回值类型是由vector定义的size_type类型 
    ```cpp
    vector<int>::size_type //正确
    vector::size_type //错误
    ```
  + 只能对确知已存在的元素执行下标操作，确保下标合法的一种有效手段是尽可能使用范围for语句。

### 3.4迭代器介绍
  + 迭代器提供了对对象的间接访问，迭代器有有效和无效之分，有效指的是指向某个元素或者容器中为元素的下一个为止，其他所有情况都是无效。  

#### 3.4.1 使用迭代器
  + 迭代器的成员begin和end。begin负责返回指向第一个元素（或第一个字符）的迭代器；end负责返回只想容器为元素的下一个为止的迭代器，也就是该迭代器指示的是容器的一个本不存在的尾后元素。特殊情况下，如果容器为空，则begin和end返回的是同一个迭代器。
    ```cpp
    auto b = v.begin(), e = v.end();
    for(auto it = v.begin(); it != v.end(); ++it) 
    	statement
    ```
  + 标准容器迭代器的运算符：
    | 方法 | 含义 |
    | :----- | :---- |
    | \*iter | 返回迭代器iter所指元素的引用 |
    | iter->mem | 解引用iter并获取该元素的名为mem的成员，等价于*(iter).mem |
    | ++iter | 令iter指示容器中的下一个元素 |
    | --iter | 令iter指示容器中的上一个元素 |
    | iter1 == iter2 | 判断两个迭代器是否相等，如果迭代器指示的是同一个元素或者它们是同一个容器的尾后迭代器，则相等，反之不相等 |
    | iter1 != iter2 | 判断两个迭代器是否不相等 |
  + 因为end返回的迭代器并不实际指向某个元素，所以不能对其进行递增或解引用的操作。
  + 迭代器的精准类型是：
    ```cpp
    vector<int>::iterator it; //it可以读写vector<int>中的元素
    string::iterator it; //it可以读写string中的元素
    
    vector<int>::const_iterator it; //it只能读元素，不能写元素
    string::const_iterator it; //it只能读字符，不能写字符
    ```
    如果容器对象是一个常量，则只能使用const_iterator,如果不是常量，则两种都可以使用。 
  + begin和end返回的具体类型由对象是否是常量决定，如果对象是常量，则返回const_iterator，如果不是常量，则返回iterator
  + `v.cbegin(); v.cend();` 返回的是const_iterator
  + 任何一种可能改变vector对象容量的操作，比如push_back()都会使该vector对象的迭代器失效。


#### 3.4.2 迭代器运算
  + vector和string迭代器支持的运算：
    | 方法 | 含义 |
    | :----- | :----- |
    | iter+n | 迭代器加上一个整数值仍得一个迭代器，迭代器指示得新位置与原来相比向前移动了若干个元素。|
    | iter-n | 向后移动了若干个元素 |
    | iter1+=n | 迭代器加法的复合赋值语句，将iter1加n的结果赋值给iter1 |
    | iter1-=n | 将iter1-n的结果赋值给iter1 |
    | >,>=,<,<= | 关系运算符，如果某迭代器指向的容器为止在另一个迭代器所指为止之前，则说前者小于后者 |
  
    














	
