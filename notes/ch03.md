## 第三章 字符串、向量和数组
### 3.1 命名空间using声明
  + using声明，每个using声明引入命名空间的一个成员`using std::cin;`  
  + 位于头文件的代码一般不应该使用using声明，因为头文件的内容会拷贝到所有引用它的文件中去，如果头文件里面有某个using声明，那么每个使用了该头文件的文件都会有这个声明，对于某些程序来说，由于不经意间包含了一些名字，反而可能产生始料未及的名字冲突。

### 3.2 标准库类型string
  + 标准库类型string表示可变长的字符序列，包含在头文件string中，string定义在命名空间std中。
    ```cpp
    #include <string>
    using std::string;
    ```
#### 3.2.1 定义和初始化string对象
  + 初始化string对象的方式：
    | 方式 | 含义 |
    | :----- | :----- |
    | string s1 | 默认初始化，s1是一个空串 |
    | string s2(s1) | s2是s1的副本 | 
    | string s2 = s1 | 等价于string s2(s1),s2是s1的副本 |
    | string s3("value") | s3是字面值"value"的副本，除了字面值最后的那个空字符外 |
    | string s3 = "value" | 等价于s3("value")，s3是字面值"value"的副本 |
    | string s4 = (n,'c') | 把s4初始化为由连续n个字符c组成的串 |
    
  + 拷贝初始化，使用等号初始化一个变量，编译器把等号右侧的初始值拷贝到新建的对象中去。直接初始化，不使用等号。

#### 3.2.2 string对象上的操作
  + string的操作：
    | 操作 | 含义 |
    | :----- | :----- |
    | os<<s | 将s写入到输出流os当中，返回os |
    | is>>s | 从is中读取字符串赋给s，字符串以空白分隔，返回is |
    | getline(is, s) | 从is中读取一行赋给s，返回is | 
    | s.empty() | s为空返回true,否则返回false | 
    | s.size() | 返回s中字符的个数 | 
    | s[n] | 返回s中第n个字符的引用，位置n从0计起 |
    | s1+s2 | 返回s1和s2连接后的结果 |
    | s1=s2 | 用s2的副本代替s1中原来的字符串 |
    | s1==s2 | 如果s1和s2中所包含的字符完全一样，则返回true |
    | s2!=s2 | 如果s1和s2中所包含的字符不完全一样，则返回false | 
    | <,<=,>,>= | 利用字符在字典中的顺序进行比较 |
  + 使用cin>>string对象会自动忽略开头的空白（空格符、换行符、制表符等）并从第一个真正的字符开始读取，直到遇到下一处空白为止。读取未知数量的string对象：
    ```cpp
    while(cin>>str)
      statement;
    ```
  + 使用getline读取一整行，保留其中的空白符，两个参数是输入流和string对象，函数从给定的输入流中读取字符，直到遇到换行符，string中不保存换行符，可能会读取到空字符串（当直接遇到换行符的时候），并且可以用这个函数作为while的条件表达式，直到读取到文件结尾为止。
  + string.empty()返回的是一个string::size_type类型，是一个无符号类型的值，并且足够存放下任何string对象的大小，如果一条表达式中已经有了size()函数就不要再使用int，否则可能会导致出错，使用`auto len = s.size();` 获取字符串大小并且类型也保持一致。
  + 比较字符串大小：
    + 如果两个string对象的长度不同，而且较短的string对象的每个字符都与较长的string对象对应位置上的字符相同，就说较短的string对象小于较长string对象。
    + 如果两个string对象在某些对应的为止不一致，则string对象比较的结果是string对象中第一对相异字符比较的结果。  
  + 字面值和string对象相加，必须保证每个加法运算符（+）的两侧运算对象至少有一个是string:
    ```cpp
    string s6 = s1 + ", " + "world"; //正确
    stirng s7 = "hello" + ", " + s2; //错误
    ```
    s1 + ", "的结果是一个string对象，同时作为第二个加法运算符的左侧运算对象，因此正确。"hello" + ", "是错误的，因为试图将两个字面值加在一起。  
  + C++中的字符串字面值并不是标准库类型string的对象，二者是不同的类型。
#### 3.2.3 处理string对象中的字符
  + cctype头文件中定义的对字符的操作:
     | 函数 | 含义 |
     | :----- | :----- |
     | isalnum(c) | 当c是字母或数字的时候为真 |
     | isalpha(c) | 当c是字母的时候为真 |
     | iscntrl(c) | 当c是控制字符时为真 |
     | isdigit(c) | 当c是数字时为真 |
     | isgraph(c) | 当c不是空格且可打印时为真 |
     | islower(c) | 当c是小写字母时为真 |
     | isprint(c) | 当c是可打印字符时为真 |
     | ispunct(c) | 当c是标点符号时为真 |
     | isspace(c) | 当c是空白时为真（空格、横向制表符、纵向制表符、回车符、换行符、进纸符） | 
     | isupper(c) | 当c是大写字母时为真 |
     | isxdigit(c) | 当c是十六进制数字时为真 | 
     | tolower(c) | 如果c是大写字母，输出对应的小写字母，否则原样输出c |
     | toupper(c) | 如果c是小写字母，输出对应的大写字母，否则原样输出c |
  + 使用范围for语句遍历每个字符。
    ```cpp
      for(declaration: expression)
        statement
      
      for(auto c : str)
        cout<<c<<endl;
    ```
  + 如果要使用范围for语句改变string中的值，必须把循环变量定义成引用类型，因为只有定义成了引用才能让循环变量每次绑定到对应的字符，才能对原字符串继续宁修改。
    ```cpp
    for(auto &c : s)
      c = toupper(c)
    ```
  + 可以通过下标访问，str[n]访问第n+1个字符，返回的是该位置上的引用。如果是空字符串使用下标访问一定不在正常的索引范围内，会引发不可预知的后果。只要字符串不是常量就能为下标运算符返回的字符赋予新值。

### 3.3标准库类型vector
  + 标准库类型vector表示的是对象的集合，也被称为容器，因为其可以容纳其他对象。 
    ```cpp
		#include <vector>
		using std::vector;
		```
  + vector能容纳绝大多数类型的对象作为其元素，但是因为引用不是对象，所以不存在包含引用的vector

#### 3.3.1 定义和初始化vector对象
  + 初始化vector对象的方法：  
     | 方法 | 含义 |
     | :----- | :----- |
     | vector/<T/> v1 | v1是一个空vector，它潜在的元素是T类型的，执行默认初始化 |
     | vector/<T/> v2(v1) | v2中包含v1所有元素的副本 |
     | vector/<T/> v2=v1 | 等价于v2(v1),v2中包含v1所有元素的副本 |
     | vector/<T/> v3(n,val) | v3中包含了n个重复的元素，每个元素的值都是val |
     | vecotr/<T/> v4(n) | v4中包含了n个重复地执行了值初始化的对象 |
     | vector/<T/> v5{a,b,c...} | v5包含了初始化值元素的个数，每个元素被赋予相应的初始值 |
     | vector/<T/> v5={a,b,c...} | 等价于v5{a,b,c...} |
 

#### 3.3.2 向vector对象中添加元素
  + 对于vector对象，直接初始化方法适用于三种情况：
    + 初始值已知且数量较少
    + 初始值是另一个vector对象的副本
    + 所有元素的初始值都一样
  + `vector.push_back(value)` 向vector对象末尾添加一个元素，vector对象可以实现高速添加元素。
  + 如果循环体内部包含有向vector对象添加元素的语句，则不能使用范围for循环。  

#### 3.3.3 其他vector操作
  + vector支持的操作：  
    | 方法 | 含义 |  
    | :----- | :----- |
    | v.empty() | 如果v中不含有任何元素，返回真；否则返回假 | 
    | v.size() | 返回v中元素的个数 |
    | v.push_back(t) | 向v的末端添加一个值为t的元素 |
    | v[n] | 返回v中第n个位置上的引用（从0开始） |
    | v1=v2 | 用v2的元素拷贝替换v1中的元素 |
    | v1={a,b,c...} | 用列表中的元素拷贝替换v1中的元素 |
    | v1==v2 | v1和v2相等当且仅当元素数量相同且对应位置的元素值都相同 |
    | v1!= v2 | v1不等于v2返回true,否则返回false |
    | <,<=,>,>= | 以字典顺序进行比较 |
  
  + v.size()返回值类型是由vector定义的size_type类型 
    ```cpp
    vector<int>::size_type //正确
    vector::size_type //错误
    ```
  + 只能对确知已存在的元素执行下标操作，确保下标合法的一种有效手段是尽可能使用范围for语句。

### 3.4迭代器介绍
  + 迭代器提供了对对象的间接访问，迭代器有有效和无效之分，有效指的是指向某个元素或者容器中为元素的下一个为止，其他所有情况都是无效。  

#### 3.4.1 使用迭代器
  + 迭代器的成员begin和end。begin负责返回指向第一个元素（或第一个字符）的迭代器；end负责返回只想容器为元素的下一个为止的迭代器，也就是该迭代器指示的是容器的一个本不存在的尾后元素。特殊情况下，如果容器为空，则begin和end返回的是同一个迭代器。
    ```cpp
    auto b = v.begin(), e = v.end();
    for(auto it = v.begin(); it != v.end(); ++it) 
    	statement
    ```
  + 标准容器迭代器的运算符：
    | 方法 | 含义 |
    | :----- | :---- |
    | \*iter | 返回迭代器iter所指元素的引用 |
    | iter->mem | 解引用iter并获取该元素的名为mem的成员，等价于*(iter).mem |
    | ++iter | 令iter指示容器中的下一个元素 |
    | --iter | 令iter指示容器中的上一个元素 |
    | iter1 == iter2 | 判断两个迭代器是否相等，如果迭代器指示的是同一个元素或者它们是同一个容器的尾后迭代器，则相等，反之不相等 |
    | iter1 != iter2 | 判断两个迭代器是否不相等 |
  + 因为end返回的迭代器并不实际指向某个元素，所以不能对其进行递增或解引用的操作。
  + 迭代器的精准类型是：
    ```cpp
    vector<int>::iterator it; //it可以读写vector<int>中的元素
    string::iterator it; //it可以读写string中的元素
    
    vector<int>::const_iterator it; //it只能读元素，不能写元素
    string::const_iterator it; //it只能读字符，不能写字符
    ```
    如果容器对象是一个常量，则只能使用const_iterator,如果不是常量，则两种都可以使用。 
  + begin和end返回的具体类型由对象是否是常量决定，如果对象是常量，则返回const_iterator，如果不是常量，则返回iterator
  + `v.cbegin(); v.cend();` 返回的是const_iterator
  + 任何一种可能改变vector对象容量的操作，比如push_back()都会使该vector对象的迭代器失效。


#### 3.4.2 迭代器运算
  + vector和string迭代器支持的运算：
    | 方法 | 含义 |
    | :----- | :----- |
    | iter+n | 迭代器加上一个整数值仍得一个迭代器，迭代器指示得新位置与原来相比向前移动了若干个元素。|
    | iter-n | 向后移动了若干个元素 |
    | iter1+=n | 迭代器加法的复合赋值语句，将iter1加n的结果赋值给iter1 |
    | iter1-=n | 将iter1-n的结果赋值给iter1 |
    | >,>=,<,<= | 关系运算符，如果某迭代器指向的容器为止在另一个迭代器所指为止之前，则说前者小于后者 |
  
    
### 3.5数组
#### 3.5.1 定义和初始化内置数组
  + 数组的维度必须是一个常量，如果在函数内部定义了某种内置类型的数组，那么默认初始化会令数组含有未定义的值。定义数组的时候必须指定数组的类型，不允许用auto关键字由初始值的列表推断类型，数组的元素应该是对象，因此不存在引用数组。
  + 如果在声明的时候没有指明维度，编译器会根据初始值的数量计算并推测出来。如果指明了维度，那么初始值的总数量不应该超出指定的大小。如果维度比提供的初始值数量大，则用提供的初始值的初始化靠前的元素，剩下的元素被初始化成默认值。
  + 字符数组有一种额外的初始化形式，可以使用字符串字面值对此类数组初始化，当使用这种方式的时候，一定要注意字符串字面值的结尾处还有一个空字符，这个空字符也会像字符串的其他字符一样被拷贝到字符数组中去。
  + 不能将数组的内容拷贝给其他数组作为其初始值，也不能用数组为其他数组赋值。
	```cpp
	int a[] = {0,1,2}; 
	int a2[] = a; //错误，不允许使用一个数组初始化另一个数组
	a2 = a; //错误，不能把一个数组直接赋值给另一个数组
	```
  + 可以定义存放指针的数组，定义数组的指针及数组的引用
	```cpp
	int *ptrs[10]; //ptrs是含有10个整型指针的数组
	int &refs[10]; //错误，不存在引用的数组
	int (*Parray)[10] = &arr; //Parray指向一个含有10个整数的数组
	int (&arrRef)[10] = arr; //arrRef引用一个含有10个整数的数组
	```
	  对于Parray,首先看括号括起来的内容，表明这是一个指针，然后看右边，直到这是一个指向大小为10的数组的指针，再看int表明，Parray是一个指针，指向一个int数组，数组中包含10个元素。
 
#### 3.5.2 访问数组元素
  + 可以使用下标和范围four语句进行访问。

#### 3.5.3 指针和数组
  + 在很多用到数组名字的地方，编译器都会自动地将其替换为一个指向数组首元素地指针，当使用数组作为一个auto变量地初始值时，推断得到地类型是指针而不是数组，但是使用decltype关键字得到地是数组而不是指针。
  + 定义在头文件iterator中的begin和end函数可以对数组进行操作，begin函数返回指向ia首元素的指针，end函数返回指向ia尾元素下一为止的指针。
    ```cpp
    int *beg = begin(arr);
    int *last = end(arr);
    ```
  + 指向数组元素的指针可以执行大部分的迭代器的运算，例如解引用、递增、比较、与整数相加、两个指针相减等等。允许给空指针加上或减去一个值为0的整型常量表达式，两个空指针彼此相减结果为。
  + 数组的下标可以是负值a[-1]相当于*(a-1)

#### 3.5.4 C风格字符串
   + 字符串字面值是C风格字符串,包含结尾空字符，头文件cstring中定义了一些操作C风格字符串的函数。可用于字符数组，不过结尾要有空字符，也可以用于char *
     | 方法 | 含义 |
     | :----- | :----- |
     | strlen(p) | 返回p的长度，空字符串不计算在内 |
     | strcmp(p1, p2) | 比较p1和p2的相等性。相等返回0，p1大返回一个正值，p2大返回一个负值 |
     | strcat(p1, p2) | 将p2附加到p1后面，返回p1 | 
     | strcpy(p1, p2) | 将p2拷贝给p1，返回p1 |

#### 3.5.5 与旧代码的接口
  + 允许使用字符串字面值来初始化string对象；
  + 任何出现字符串字面值的地方都可以用以空字符结束的字符数组来替代；
  + 允许使用以空字符结束的字符数组来初始化string对象或为string对象赋值。  
  + 在string对象的加法运算中允许使用以空字符结束的字符数组作为其中一个运算对象（不能两个运算对象都是），在string对象的复合赋值运算中允许使用以空字符结束的字符数组作为右侧的运算对象。
  + 如果某处需要一个C风格的字符串，无法直接用string对象来替代，可以使用s.c_str()返回的是一个C风格的字符串，返回结果是一个指针，该指针指向一个以空字符结束的字符数组，指针的类型是const char \*.无法保证c_str()函数返回的数组一直有效，如果后续操作操作改变了s的值，可能会让之前的数组失去效用，最好将该数组重新拷贝一份。
  + 允许使用数组来初始化vector对象，只需要指明拷贝区域的首元素地址和尾后地址就可以。  
    ```cpp
    int arr[] = {0,1,2,3,4,5};
    vector<int> ivec(begin(arr),end(arr));
    ```


### 3.6 多维数组
  + 多维数组就是数组的数组，允许使用花括号括起来的一组值初始化多维数组，多维数组的每一行分别使用花括号括起来.内层嵌套的括号是非必需的.初始化的时候可以不讲所有初始值写出来
    ```cpp
    int ia[3][4]={
    	{0,1,2,3},
	{4,5,6,7},
	{8,9,10,11}
    };
    int ia[3][4] = {0,1,2,3,4,5,6,7,8,9,10,11};
    int ia[3][4] = {
    	{0},
	{4},
	{8}
    };
  + 如果表达式含有的下标运算符的数量和数组维度一样多，该表达式的结果将是给定类型的元素。如果表达式含有的下标运算符的数量比数组的维度小，则表达式的结果将是给定索引处的一个内存数组
  + 使用范围for语句处理多维数组
    ```cpp
    int cnt = 0;
    for(auto &row:ia)
    	for(auto &col:row)
				col = cnt++;
    ```
  + 这个循环中没有任何写操作，但还是将外层循环的控制变量声明成了引用的类型，这是为了避免数组被自动转化为指针
    ```cpp
		for(const auto &row:ia)
			for(auto col:row)
				cout<<col<<endl;
		
		for(auto row:ia)
			for(auto col:row) //错误
				cout<<col<<endl;
    ```
    上述第二个程序编译出错，因为此时row是一个int\*指针，这样内存的循环就不合法了，使用范围for语句处理多维数组，除了最内存的循环外，其他所有循环的控制变量都应该是引用类型，如果不想改变数组的值，可以使用const修饰
  + 当程序使用多维数组的名字时，也会自动将其转换成指向数组首元素的指针。
    ```cpp
		int ia[3][4];
		int (*p)[4] = ia; // int *p = ia[0];  完成的效果差不多，但是意义不同，具体的操作也略有不同，++p一个指向下一行，一个指向下一个
		p = &ia[2];
    ```
  + 外层fou循环受限声明一个指针p令其指向ia的第一个内层数组，递增运算++p负责将p指针移动到ia的下一行
    ```cpp
		for(auto p = ia; p != ia + 3; ++p){
			for(auto q = *p; q != *p + 4; ++q)
				cout<<*q<<" ";
			cout<<endl;
		}
    ```
 









	
