## 第十四章 重载运算与类型转换

### 14.1 基本概念

+ 重载的运算符是具有特殊名字的函数：它们的名字由关键字operator和其后要定义的运算符号组成。

+ 重载运算符函数的参数数量与该运算符作用的运算对象数量一样多

+ 如果一个运算符函数是成员函数，则它的第一个（左侧）运算对象绑定到隐式this指针上

+ 对于一个运算符函数来说，它或者是类的成员，或者至少含有一个类类型的参数，意味着当运算符作用域内置类型的运算对象时，我们无法改变该运算符的含义

+ 可以被重载的运算符：
  
  |     |     |     |       |        |          |
  | --- | --- | --- | ----- | ------ | -------- |
  | +   | -   | *   | /     | %      | ^        |
  | &   |     |     | ~     | !      | ,        |
  | <   | >   | <=  | >=    | ++     | --       |
  | <<  | >>  | ==  | !=    | &&     |          |
  | +=  | -=  | /=  | %=    | ^=     | &=       |
  |     | =   | *=  | <<=   | >>=    | []       |
  | ->  | ->* | new | new[] | delete | delete[] |

+ 不能被重载的运算符：::   .*  .   ?:

+ 某些运算符不能被重载，包含求值顺序的运算符，逻辑与、逻辑或，逗号，因为关于运算对象求值顺序的规则无法应用到重载的运算符上

+ 使用与内置类型一致的含义：
  
  + 如果类执行IO操作，则定义移位运算符使其与内置类型的IO保持一致
  
  + 如果类的某个操作是检查相等性，则定义operator==，如果类有了operator==，则通常也会定义operator!=
  
  + 如果类包含一个内在的单序比较操作，则定义operator<,如果类定义了operator<，则通常也应该有其他关系比较符
  
  + 重载运算符的返回类型通常应该与内置版本的返回类型兼容：逻辑运算符和关系运算符返回bool,算术运算符应该返回一个类类型的值，赋值运算符和复合赋值运算符应该返回左侧运算对象的一个引用

+ 运算符定义为成员函数还是非成员函数：
  
  + 赋值(=),下标([]),调用(())和成员访问箭头(->)运算符必须是成员函数
  
  + 复合赋值运算符一般也应该是成员函数，但非必须
  
  + 改变对象状态的运算符挥着与给定类型密切相关的运算符，如递增、递减和解引用运算符，通常应该是成员函数
  
  + 具有对称性的运算符可能转换任意一端的云端对象，例如算术算术、相等性、关系和位运算符等，因此通常应该是普通函数
  
  ```cpp
  string s="world";
  string t=s+"!";
  string u="hi"+s;//如果+是string成员，则产生错误
  ```

### 14.2 输入和输出运算符

#### 14.2.1 重载输出运算符<<

+ 输出运算符第一个形参是一个非常量的ostream对象的引用，第二个形参一般来说是一个常量的引用，该常量是我们想要打印的类类型

+ 为了与其他输出运算符保持一致，operator<<一般要返回ostream形参

+ 与iostream标准库兼容的输入输出运算符必须是普通的非常远函数，而不能是类的成员函数，否则，它们的左侧运算对象将是我们的类的一个对象，因此IO运算符一般被声明为友元函数

#### 14.2.2 重载输入运算符>>

+ 输入运算符第一个形参是运算符将要读取的流的引用，第二个形参是将要读入到的（非常量）对象的引用，返回某个给定流的对象

+ 输入运算符必须处理输入可能失败的情况，而输出运算符不需要

+ 执行输入运算符可能发生的错误：
  
  + 当流含有错误类型的数据时读取操作可能失败。
  
  + 当流读取到文件末尾或者遇到输入流的其他错误时也会失败

### 14.3 算术和关系运算符

+ 通常情况下，将算术和关系运算符定义成非成员函数以允许对左侧或右侧的运算对象进行转换，形参都是常量的引用

+ 如果类同时定义了算术运算符和相关的复合赋值运算符，则通常情况下应该使用复合赋值来实现算术运算符

#### 14.3.1 相等运算符

+ 设计原则：
  
  + 如果一个类含有判断两个对象是否相等的操作，则它应该把函数定义成operator==而非一个普通的命名函数，不仅容易记忆，而且更容易使用标准库容器和算法
  
  + 如果类定义了operator==，则该运算符应该能判断一组给定的对象中是否含有重复数据
  
  + 通常情况下，相等运算符具有传递性，也就是如果a==b,b==c为真,则a==c成立
  
  + 如果类定义了operator==，则也应该定义operator!=
  
  + 相等运算符和不相等运算符中的一个应该把工作委托给定另一个，这意味着其中一个运算符应该负责实际比较对象的工作，而另一个只是调用那个真正工作的运算符

#### 14.3.2 关系运算符

+ 定义了相等运算符的类也常常（但不总是）包含关系运算符

+ 关系运算符应该：
  
  + 定义顺序关系，令其与关联容器中对关键字的要求一致
  
  + 如果类同时也含有==运算符，则定义一种关系令其与==保持一致，也就是如果两个对象时!=,那么一个对象应该<另一个对象

### 14.4 赋值运算符

+ 在拷贝赋值和移动赋值运算符之外，标准库vector类还定义了第三种赋值运算符，该运算接受花括号内的元素列表作为参数
  
  ```cpp
  StrVec &StrVec::operator=(initialzer_list<string> li){
      auto data = alloc_n_copy(li.begin(),li.end());
      free();//销毁对象中的元素并释放内存空间
      elements = data.first; //更新数据成员使其指向新空间
      return *this;
  }
  ```

    重载的赋值运算符必须显示放当前内存空间，再创建一片新空间

+ 赋值运算符必须定义成类的成员，复合赋值运算符通常情况下也应该这样

### 14.5 下标运算符

+ 为了与下标的原始定义兼容，下标运算符通常以所访问元素的引用作为返回值，好处是下标可以出现在赋值运算符的任意一端，最好同时定义下标运算符的常量和非常量版本

### 14.6 递增和递减运算符

+ 为了区分前置和后置运算符，后置版本接受一个额外的（不被使用）int类型的形参，当我们使用后置运算符时，编译器为这个形参提供一个值为的实参

+ 后置运算符返回的是值而不是引用

### 14.7 成员访问运算符

+ point->mem的执行过程：
  
  + 如果point是指针，则应用内置的箭头运算符，表达式等价于(*point*.mem)
  
  + 如果point是定义了operator->的类的一个对象，则使用point.operator->()的结果来获取mem。

+ 重载的箭头运算符必须返回类的指针或者自定义的箭头运算符的某个类的对象

### 14.8 函数调用运算符

+ 可以通过类或者类的对象来调用

+ 函数调用运算符必须是成员函数，一个类可以定义多个不同版本的调用运算符，相互之间应该在参数数量或类型上有所区别

+ 如果类定义了调用运算符。则该类的对象被称作函数对象，函数对象常常作为泛型算法的实参
  
  ```cpp
  class PrintString{
  public:
      PrintString(ostream &o=cout,char c=' '):os(o),sep(c){}
      void operator()(const string &s)const{os<<s<<sep;}
  private:
      ostream &os;
      char sep;
  };
  for_each(vs.begin(),vs.end(),PrintString(cerr,'\n'));
  ```

#### 14.8.1 lambda是函数对象

+ 当我们编写一个lambda后，编译器将表达式翻译成一个未命名类的未命名对象，在lambda表达式产生的类中含有一个重载的函数调用运算符，例如下面两个的行为类似
  
  ```cpp
  stable_sort(words.begin(),words.end(),[](const string &a, const string &b){return a.size() < b.size();});
  
  class ShorterString{
  public:
      bool operator()(const string &s1, const string &s2)const{
      return s1.size() < s2.size();
  }
  };
  stable_sort(words.begin(),words.end(),ShorterString());
  ```

+ 当一个lambda表达式通过引用捕获变量时，将由程序负责确保lambda执行时引用所引得对象确实存在，因此编译器可以直接使用该引用而无须在lambda产生的类中将其存储未数据成员。

+ 通过值捕获的变量被拷贝到lambda中，因此这种lambda产生的类必须未每个值捕获的变量捡起对应的数据成员，同时创建构造函数，令其使用捕获的变量的值来初始化数据成员

+ lambda表达式产生的类不含默认构造函数、赋值运算符及默认析构函数，其是否含有默认的拷贝/移动构造函数则通常要看捕获的数据成员的类型而定。

#### 14.8.2 标准库定义的函数对象

+ 标准库定义了一组表示算术运算符、关系运算符和逻辑运算符的类，每个类分别定义了一个执行命名操作的调用运算符，这些类都定义成模板的形式，可以为其指定具体的应用类型，这里的类型即调用运算符的形参类型。都定义在functional头文件中

+ 标准库函数对象
  
  | 算术               | 关系                  | 逻辑                |
  | ---------------- | ------------------- | ----------------- |
  | plus<Type>       | equal_to<Type>      | logical_and<Type> |
  | minus<Type>      | not_equal_to<Type>  | logical_or<Type>  |
  | multiplies<Type> | greater<Type>       | logical_not<Type> |
  | divides<Type>    | greater_equal<Type> |                   |
  | modulus<Type>    | less<Type>          |                   |
  | negate<Type>     | less_equal<Type>    |                   |
  |                  |                     |                   |
  |                  |                     |                   |

+ 表示运算符的函数对象类长用来替换算法中的默认运算符`sort(svec.begin(),svec.end(),greater<string>())`

+ 需要注意的是，标准库规定其函数对象对于指针同样适用。正常比较两个无关指针将产生未定义的行为，但是我们可能会希望通过比较指针的内存地址来sort指针的vector，直接这么做将产生未定义的行为，因此可以使用一个标准库函数对象来实现该目的
  
  ```cpp
  vector<string *> nameTable;
  sort(nameTable.begin(),nameTable.end(),[](string *a,string *b){return a<b;}); //错误，nameTable中的指针没有关系，所以<将产生未定义的行为
  sort(nameTable.begin(),nameTable.end(),less<string *>()); //正确
  ```



#### 14.8.3 可调用对象与function

+ C++语言中有几种可调用的对象：函数、函数指针、lambda表达式、bind创建的对象以及重载了函数调用运算符的类型

+ 可调用对象也有类型，例如，每个lambda有它自己唯一的类类型，函数以函数指针的类型则由其返回值和实参类型决定

+ 两个不同类型的可调用对象却可能共享同一种调用形式，调用形式指明了调用返回的类型以及传递给调用的实参类型，一种调用形式对应一个函数类型，例如`int(int,int)`是一个函数类型，它接受两个int,返回一个int

+ 不同类型可能具有相同的调用形式：
  
  ```cpp
  //普通函数
  int add(int i, int j){return i + j;}
  //lambda其产生一个未命名的函数对象类
  auto mod = [](int i, int j){return i % j;};
  //函数对象类
  struct divide{
      int operator()(int denominator,int divisor){
      return denominator / divisor;
  }  
  };
  ```

+ 可以定义一个函数表用于存储指向这些可调用对象的“指针”，可以使用map,使用一个表示运算符符号的string对象作为关键字，使用实现运算符的函数作为值

+ 假定我们所有的函数都相互独立，并且只处理关于int的二元运算,`map<string,int(*)(int,int)>binops;`，可以使用`binops.insert({"+",add});`但是不能将mod或者divide存入binops中，云隐是mod是一个lambda表达式，而每个lambda都有其自己的类类型，该类型与存储在binops中的值的类型不匹配

+ 可以使用一个名为function的新的标准库类型解决上述问题，function操作：
  
  | 操作                           | 含义                                              |
  | ---------------------------- | ----------------------------------------------- |
  | function<T> f;               | f是一个用来存储可调用对象的空function，这些可调用对象的调用i形式应该与函数类型T相同 |
  | function<T>f(nullptr)        | 显式地构造一个空function                                |
  | function<T>f(obj)            | 在f中存储可调用对象obj的副本                                |
  | f                            | 将f作为条件，当f中含有一个可调用对象时为真，否则为假                     |
  | f(args)                      | 调用f中的对象，参数是args                                 |
  |  |                                                 |
  
  
