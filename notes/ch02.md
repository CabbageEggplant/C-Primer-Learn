## 第二章 变量和基本类型

### 2.1 基本内置类型
  + C++定义了一套算数类型和空类型。当函数不返回任何值时返回空类型(void)作为返回类型。  
  + C++标准规定了尺寸的最小值，同时允许编译器赋予这些类型更大的尺寸。  
    | 类型 | 含义 | 最小尺寸 |
    | :----: | :----: | :----: |
    | bool | 布尔类型 | 未定义 |
    | char | 字符 | 8位 |
    | wchar_t | 宽字符 | 16位|
    | char16_t | Unicode字符 | 16位 |
    | char32_t | unicode字符 | 32位 |
    | short | 短整型 | 16位 |
    | int | 整型 | 16位 |
    | long | 长整型 | 32位 |
    | long long | 长整型 | 64位 |
    | float | 单精度浮点型 | 6位有效数字 |
    | double | 双精度浮点型 | 10位有效数字 |
    | long double | 扩展精度浮点型 | 10位有效数字 |
    
  + 为了赋予内存中某个地址明确的含义，必须首先直到存储在该地址的数据的类型。类型决定了数据所占的比特数以及该如何解释这些比特的内容。  
  + 除去布尔型和扩展的字符型之外，其他整型可以划分为带符号的和无符号的两种。
  + 字符型有三种char、unsigned char、signed char。char是否是有符号的由编译器决定。  
  + C++应该尽可能的接近硬件。以下是选择类型的一些经验准则：  
    + 当明确知道数值不可能为负的时候，选用无符号整型。   
    + 使用int执行整数运算。在实际应用中，short常常显得太小而long一般和int有一样的尺寸。如果你的数值超过了int的表示范围，选用long long。
    + 在算数表达式中不要使用char或bool，只有在存放字符或者布尔值时才使用它们。因为类型char在一些机器上是有符号的，而在另一些机器上又是无符号的，所以如果使用char进行运算特备容易出问题。如果你需要使用一个不大的整数，那么明确指定它的类型为unsigned char或者signed char.
    + 执行浮点运算选用double，这是因为float通常精度不够而且双精度浮点型和单精度浮点型的计算代价相差不大。事实上，对于某些机器来说，双精度运算甚至比单精度运算还快。long double提供的精度在一般情况下是没有必要的，况且它带来的运行时消耗也不容忽视。  

  + 对象的类型定义了对象能包含的数据和能参与的运算，其中一种运算能被大多数类型支持，就是将对象从给定的类型转换为另一种相关类型。  
  + 类型所能表示的值的范围决定了转换的过程：  
    + 当我们把一个非布尔类型的算数值赋给布尔类型时，初始值为0则结果为false,否则结果为true.
    + 当我们把一个布尔值付给非布尔类型时，初始值为false则结果为0，初始值为true则结果为1。
    + 当我们把一个浮点数赋值给整数类型时，进行了近似处理，结果值将仅保留浮点数中小数点之前的部分。
    + 当我们把一个整数值赋值给浮点类型时，小数部分记为0，如果该整数所占空间超过了浮点类型的容量，精度可能有损失。
    + 当我们赋给无符号整型一个超出它表示范围的值时，结果时初始值对无符号类型标识数值总数取模后的余数。例如，8比特的unsigned char可以标识0到255，如果赋值一个区间外的值，则实际结果时该值对256取模得到的余数，-1则变为了255.
    + 当我们赋给带符号类型一个超出它表示范围的值时，结果时未定义的，此时程序可能继续工作、可能崩溃，也可能生成垃圾数据。   

  + 无法预知的行为源于编译器无须（有时是不能）检测的错误，即使代码编译通过了，如果程序执行了一条未定义的表达式，仍有可能产生错误。  
  + 程序应该尽量避免依赖于实现环境的行为。如果把int的尺寸看成是一个确定不变的已知值，那么这样的程序就被称作不可移植的。
  + 切勿混用带符号类型和无符号类型。**当一个算数表达式中既有无符号数又有int值时，那么int值就hi转换成无符号数。把int转换为无符号数的过程和把int直接赋给无符号变量一样。**
  + 整型字面值可以写作十进制数、八进制数或十六进制数的形式。以0开头的整数表示八进制，以0x或0X开头代表十六进制数。 20  024  014  
  + 默认情况下，十进制字面值是带符号数，八进制和十六进制字面值即可能是带符号也可能是无符号。十进制字面值的类型是int、long和long long中尺寸最小的那个，前提是这个类型要能容纳下当前的值。八进制和十六进制是int、unsigned int、long、unsigned long、long long 、unsigned long long。如果一个字面值连与之关联的最大数据类型都放不下，将产生错误。类型short没有对应的字面值。  
  + 浮点数字面值表现为一个小数或以科学计数法表示的指数，其中指数部分用E或e表示。3.14159  3.14159E0  0.  0e0  .001  
  + 由单引号括起来的一个字符成为char型字面值，双引号括起来的零个或多个字符构成字符串型字面值。  
  + 字符串字面值的类型实际上是由常量字符构成的数组，编译器在每个字符串的结尾处添加了一个空字符（'\0'），因此其实际长度要比内容多1.   
  + 有两类字符程序员不能直接使用：
    + 不可打印的字符，如退格或其他控制字符，因为它们没有可是的图符。  
    + C++语言中有特殊含义的字符，如单引号、双引号、问好、反斜线等等。这种情况需要用到转义序列，转义序列都以反斜线开始。转义字符被当作一个字符使用。  
      + 换行符      \n    横向制表符 \t    报警（响铃）符 \a  
      + 纵向制表符  \v    退格符     \b    双引号         \"  
      + 反斜线      \\    问号       \?    单引号        \'  
      + 回车符      \r    进纸符     \f
  + 泛化的转移序列，形式是\x后紧跟一个或多个十六进制的数字，或\后紧跟一个、两个或三个八进制数字，其中数字部分表示字符对应的数值。 \12换行符  \x4d  字符M. 如果反斜线\后面的白金之数字超过三个，则只有前三个与\构成转义序列，\x要用到后面跟着的所有数字。
  + 指定字面值的类型：  
       字符和字符串字面值   
     | 前缀 | 含义 | 类型 |
     | :----: | :----: | :----: |
     | u | Unicode 16字符 | char16_t |
     | U | Unicode 32字符 | char32_t |
     | L | 宽字符 | wchar_t |
     | u8 | UTF-8(仅用于字符串字面常量) | char | 
     
      整型字面值  
     | 后缀 | 最小匹配类型 |
     | :----: | :----: |
     | u or U | unsigned |
     | l or L | long |
     | ll or LL | long long |
     
      浮点型字面值  
     | 后缀 | 类型 | 
     | :----: | :----: |
     | f或F | float | 
     | l或L | long double |
     
  + 布尔类型字面值是true和false，指针字面值是nullptr.

## 2.2 变量 
  + 当对象在创建时获得了一个特定的值，我们说这个对象被初始化了。  
  + 当一次定义两个或多个变量时，对象的名字随着定义也就马上可以使用了，因此在同一条定义语句中，可以用先定义的变量值去初始化后定义的其他变量。  
  + 初始化不是赋值，初始化的含义是创建变量时赋予其一个初始值，而赋值的含义是把对象的当前值擦除，而以一个新值来替代。  
  + 列表初始化，使用花括号初始化，int a = {0}; int a{0};
  + 也可以使用小括号初始化int a(0);
  + 使用列表初始化内置变量且初始值存在丢失信息的风险，则编译器报错。
    ```cpp
    long double ld = 6.1415926;
    int a{ld}, b = {ld};
    ```
  + 默认初始化，如果定义变量时没有指定初值，则被赋予默认值。默认值是什么由变量类型决定，同时定义变量的位置也对此有影响。定义在函数main内部的内置变量不被初始化。
  + 每个类各自金耳钉其初始化对象的方式，是否允许不经初始化就定义对象也由类自己决定，如果类允许这种行为，它将决定对象的初始值是什么。
  + 为了允许把程序拆分成多个逻辑部分来编写，C++支持分离式编译机制，允许将程序分割为若干个文件，每个文件可被独立编译。如果把程序分为多个文件，则需要有在文件间共享代码的方法，一个文件的代码可能需要另一个文件中定义的变量。  
  + 为了支持分离式编译，C++将声明和定义进行区分。声明使得名字为程序所致，一个文件如果想使用别处定义的名字则必须包含对那个名字的声明。定义则创建于名字关联的实体。  
  + 声明一个变量，需要在变量名前添加关键字extern，并且不要显式初始化变量，任何包含了显示初始化的声明即成为定义，extern语句如果包含了初始值就变成了定义。  
  + 在函数体内部，如果试图初始化一个由extern关键字标记的变量，将引发错误。  
  + 变量能且只能被定义一次，但是可以被多次声明。  
  + C++是一种静态类型语言，其含义是在编译阶段检查类型，编译器负责检查数据类型是否支持要执行的运算，如果试图执行类型不支持的运算，编译器将报错并且不会生成可执行文件。  
  + C++标识符由字母、数字和下划线组成，必须以字母或下划线开头，其长度没有限制。
  + 用户自定义的标识符中不能连续出现两个下划线，也不能以下划线紧连大写字母开头，定义在函数体外的标识符不能以下划线开头。  
  + 变量命名规范：  
    + 标识符要能体现实际含义。  
    + 变量名一般用小写字母，如index，不要使用Index或INDEX。
    + 用户自定义的类型一般以大写字母，如Sales_item。
    + 如果标识符由多个单词组成，则单词间应该由明显区分，如student_loan或studentLoan，不要使用studentloan。
  + 作用域以花括号分割，同一个名字在不同的作用域中可能指向不同的实体，名字的有效区域始于名字的声明语句，以声明语句所在的作用域末端为结束。  
  + 一般第一次使用变量的时候再进行定义。  
  + 作用域可以彼此包含，被包含的作用域成为内层作用域，包含着别的作用域的作用域被称为外层作用域。作用域中一旦声明了某个名字，它所嵌套着的所有作用域中都能访问改名字，允许在内层作用域中重新定义外层作用域中已有的名字。  
  + 全局作用域本身并没有名字，所以当作用域操作符::左侧为空的时候，向全局作用域发出请求获取作用域操作符右侧名字对应的变量。  

### 2.3 复合类型
  + 



















