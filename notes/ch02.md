## 第二章 变量和基本类型

### 2.1 基本内置类型
  + C++定义了一套算数类型和空类型。当函数不返回任何值时返回空类型(void)作为返回类型。  
  + C++标准规定了尺寸的最小值，同时允许编译器赋予这些类型更大的尺寸。  
    | 类型 | 含义 | 最小尺寸 |
    | :----: | :----: | :----: |
    | bool | 布尔类型 | 未定义 |
    | char | 字符 | 8位 |
    | wchar_t | 宽字符 | 16位|
    | char16_t | Unicode字符 | 16位 |
    | char32_t | unicode字符 | 32位 |
    | short | 短整型 | 16位 |
    | int | 整型 | 16位 |
    | long | 长整型 | 32位 |
    | long long | 长整型 | 64位 |
    | float | 单精度浮点型 | 6位有效数字 |
    | double | 双精度浮点型 | 10位有效数字 |
    | long double | 扩展精度浮点型 | 10位有效数字 |
    
  + 为了赋予内存中某个地址明确的含义，必须首先直到存储在该地址的数据的类型。类型决定了数据所占的比特数以及该如何解释这些比特的内容。  
  + 除去布尔型和扩展的字符型之外，其他整型可以划分为带符号的和无符号的两种。
  + 字符型有三种char、unsigned char、signed char。char是否是有符号的由编译器决定。  
  + C++应该尽可能的接近硬件。以下是选择类型的一些经验准则：  
    + 当明确知道数值不可能为负的时候，选用无符号整型。   
    + 使用int执行整数运算。在实际应用中，short常常显得太小而long一般和int有一样的尺寸。如果你的数值超过了int的表示范围，选用long long。
    + 在算数表达式中不要使用char或bool，只有在存放字符或者布尔值时才使用它们。因为类型char在一些机器上是有符号的，而在另一些机器上又是无符号的，所以如果使用char进行运算特备容易出问题。如果你需要使用一个不大的整数，那么明确指定它的类型为unsigned char或者signed char.
    + 执行浮点运算选用double，这是因为float通常精度不够而且双精度浮点型和单精度浮点型的计算代价相差不大。事实上，对于某些机器来说，双精度运算甚至比单精度运算还快。long double提供的精度在一般情况下是没有必要的，况且它带来的运行时消耗也不容忽视。  

  + 对象的类型定义了对象能包含的数据和能参与的运算，其中一种运算能被大多数类型支持，就是将对象从给定的类型转换为另一种相关类型。  
  + 类型所能表示的值的范围决定了转换的过程：  
    + 当我们把一个非布尔类型的算数值赋给布尔类型时，初始值为0则结果为false,否则结果为true.
    + 当我们把一个布尔值付给非布尔类型时，初始值为false则结果为0，初始值为true则结果为1。
    + 当我们把一个浮点数赋值给整数类型时，进行了近似处理，结果值将仅保留浮点数中小数点之前的部分。
    + 当我们把一个整数值赋值给浮点类型时，小数部分记为0，如果该整数所占空间超过了浮点类型的容量，精度可能有损失。
    + 当我们赋给无符号整型一个超出它表示范围的值时，结果时初始值对无符号类型标识数值总数取模后的余数。例如，8比特的unsigned char可以标识0到255，如果赋值一个区间外的值，则实际结果时该值对256取模得到的余数，-1则变为了255.
    + 当我们赋给带符号类型一个超出它表示范围的值时，结果时未定义的，此时程序可能继续工作、可能崩溃，也可能生成垃圾数据。   

  + 无法预知的行为源于编译器无须（有时是不能）检测的错误，即使代码编译通过了，如果程序执行了一条未定义的表达式，仍有可能产生错误。  
  + 程序应该尽量避免依赖于实现环境的行为。如果把int的尺寸看成是一个确定不变的已知值，那么这样的程序就被称作不可移植的。
  + 切勿混用带符号类型和无符号类型。**当一个算数表达式中既有无符号数又有int值时，那么int值就hi转换成无符号数。把int转换为无符号数的过程和把int直接赋给无符号变量一样。**
  + 整型字面值可以写作十进制数、八进制数或十六进制数的形式。以0开头的整数表示八进制，以0x或0X开头代表十六进制数。 20  024  014  
  + 默认情况下，十进制字面值是带符号数，八进制和十六进制字面值即可能是带符号也可能是无符号。十进制字面值的类型是int、long和long long中尺寸最小的那个，前提是这个类型要能容纳下当前的值。八进制和十六进制是int、unsigned int、long、unsigned long、long long 、unsigned long long。如果一个字面值连与之关联的最大数据类型都放不下，将产生错误。类型short没有对应的字面值。  
  + 浮点数字面值表现为一个小数或以科学计数法表示的指数，其中指数部分用E或e表示。3.14159  3.14159E0  0.  0e0  .001  
  + 由单引号括起来的一个字符成为char型字面值，双引号括起来的零个或多个字符构成字符串型字面值。  
  + 字符串字面值的类型实际上是由常量字符构成的数组，编译器在每个字符串的结尾处添加了一个空字符（'\0'），因此其实际长度要比内容多1.   
  + 有两类字符程序员不能直接使用：
    + 不可打印的字符，如退格或其他控制字符，因为它们没有可是的图符。  
    + C++语言中有特殊含义的字符，如单引号、双引号、问好、反斜线等等。这种情况需要用到转义序列，转义序列都以反斜线开始。转义字符被当作一个字符使用。  
      + 换行符      \n    横向制表符 \t    报警（响铃）符 \a  
      + 纵向制表符  \v    退格符     \b    双引号         \"  
      + 反斜线      \\    问号       \?    单引号        \'  
      + 回车符      \r    进纸符     \f
  + 泛化的转移序列，形式是\x后紧跟一个或多个十六进制的数字，或\后紧跟一个、两个或三个八进制数字，其中数字部分表示字符对应的数值。 \12换行符  \x4d  字符M. 如果反斜线\后面的白金之数字超过三个，则只有前三个与\构成转义序列，\x要用到后面跟着的所有数字。
  + 指定字面值的类型：  
       字符和字符串字面值   
     | 前缀 | 含义 | 类型 |
     | :----: | :----: | :----: |
     | u | Unicode 16字符 | char16_t |
     | U | Unicode 32字符 | char32_t |
     | L | 宽字符 | wchar_t |
     | u8 | UTF-8(仅用于字符串字面常量) | char | 
     
      整型字面值  
     | 后缀 | 最小匹配类型 |
     | :----: | :----: |
     | u or U | unsigned |
     | l or L | long |
     | ll or LL | long long |
     
      浮点型字面值  
     | 后缀 | 类型 | 
     | :----: | :----: |
     | f或F | float | 
     | l或L | long double |
     
  + 布尔类型字面值是true和false，指针字面值是nullptr.

## 2.2 变量 
  + 当对象在创建时获得了一个特定的值，我们说这个对象被初始化了。  
  + 当一次定义两个或多个变量时，对象的名字随着定义也就马上可以使用了，因此在同一条定义语句中，可以用先定义的变量值去初始化后定义的其他变量。  
  + 初始化不是赋值，初始化的含义是创建变量时赋予其一个初始值，而赋值的含义是把对象的当前值擦除，而以一个新值来替代。  
  + 列表初始化，使用花括号初始化，int a = {0}; int a{0};
  + 也可以使用小括号初始化int a(0);
  + 使用列表初始化内置变量且初始值存在丢失信息的风险，则编译器报错。
    ```cpp
    long double ld = 6.1415926;
    int a{ld}, b = {ld};
    ```
  + 默认初始化，如果定义变量时没有指定初值，则被赋予默认值。默认值是什么由变量类型决定，同时定义变量的位置也对此有影响。定义在函数main内部的内置变量不被初始化。
  + 每个类各自金耳钉其初始化对象的方式，是否允许不经初始化就定义对象也由类自己决定，如果类允许这种行为，它将决定对象的初始值是什么。
  + 为了允许把程序拆分成多个逻辑部分来编写，C++支持分离式编译机制，允许将程序分割为若干个文件，每个文件可被独立编译。如果把程序分为多个文件，则需要有在文件间共享代码的方法，一个文件的代码可能需要另一个文件中定义的变量。  
  + 为了支持分离式编译，C++将声明和定义进行区分。声明使得名字为程序所致，一个文件如果想使用别处定义的名字则必须包含对那个名字的声明。定义则创建于名字关联的实体。  
  + 声明一个变量，需要在变量名前添加关键字extern，并且不要显式初始化变量，任何包含了显示初始化的声明即成为定义，extern语句如果包含了初始值就变成了定义。  
  + 在函数体内部，如果试图初始化一个由extern关键字标记的变量，将引发错误。  
  + 变量能且只能被定义一次，但是可以被多次声明。  
  + C++是一种静态类型语言，其含义是在编译阶段检查类型，编译器负责检查数据类型是否支持要执行的运算，如果试图执行类型不支持的运算，编译器将报错并且不会生成可执行文件。  
  + C++标识符由字母、数字和下划线组成，必须以字母或下划线开头，其长度没有限制。
  + 用户自定义的标识符中不能连续出现两个下划线，也不能以下划线紧连大写字母开头，定义在函数体外的标识符不能以下划线开头。  
  + 变量命名规范：  
    + 标识符要能体现实际含义。  
    + 变量名一般用小写字母，如index，不要使用Index或INDEX。
    + 用户自定义的类型一般以大写字母，如Sales_item。
    + 如果标识符由多个单词组成，则单词间应该由明显区分，如student_loan或studentLoan，不要使用studentloan。
  + 作用域以花括号分割，同一个名字在不同的作用域中可能指向不同的实体，名字的有效区域始于名字的声明语句，以声明语句所在的作用域末端为结束。  
  + 一般第一次使用变量的时候再进行定义。  
  + 作用域可以彼此包含，被包含的作用域成为内层作用域，包含着别的作用域的作用域被称为外层作用域。作用域中一旦声明了某个名字，它所嵌套着的所有作用域中都能访问改名字，允许在内层作用域中重新定义外层作用域中已有的名字。  
  + 全局作用域本身并没有名字，所以当作用域操作符::左侧为空的时候，向全局作用域发出请求获取作用域操作符右侧名字对应的变量。  

### 2.3 复合类型
  + 复合类型是指基于其他类型定义的类型，例如引用、指针等。
  + 引用为对象起了另外一个名字，通过&完成引用。`int ival = 1024; int &refVal = ival;`
  + 定义引用时，程序把引用和它的初始值绑定在一起，而不是将初始值拷贝给引用，无法令引用重新绑定到另外一个对象，因此引用必须初始化。
  + 定义了一个引用，对其进行的所有操作都是在与之绑定的对象上进行的。  
  + 引用本身不是一个对象，所以不能定义引用的引用，但是一个对象可以有多个引用，并且新的引用可能通过旧引用来初始化。 
  + 引用只能绑定在对象上，而不能与字面值或某个表达式的计算结果绑定在一起。  
  + 引用类型必须一致。  
  + 因为引用不是对象，没有地址，所以没有指向引用的指针
    ```cpp
    int v = 1;
    int &ri = v;
    int &*p = &ri;
    ```
    对于int &\*p,最靠近p的是*，所以p是指针，int &表明这是一个指向类型的类型，这样编译器报错。  
  + 存在指针的引用。
    ```cpp
    int v = 1;
    int *p = &v;
    int *&rp = p;
    ```
  + 指针实现了对其他对象的间接访问。指针与引用的不同：
    + 指针本身就是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内可以先后指向几个不同的对象。
    + 指针可以在定义时不赋初值。  
  + 定义指针的形式 `int i = 10; int *p = &i;`,如果在一条语句中定义了几个指针变量，每个便两千都必须有符号\* 这里的&是取地址符
  + 指针的类型和指向对象的类型必须一致，否则会产生错误。
  + 指针值应该属于西面四种状态之一：
    + 指向一个对象
    + 指向紧邻对象所占空间的下一个位置
    + 空指针，意味着指针没有指向任何对象
    + 无效指针，前三种情况之外的其他值
  + 使用\*p，来访问指针指向的对象。
  + 空指针不知想任何对象，其有三种方式：
    + `int *p = nullptr;`    推荐
    + `int *p = 0;`
    + `int *p = NULL;`
  + NULL是预处理变量，其值就是0，C++最好使用nullptr，避免使用NULL
  + 指针作为条件表达式，如果指针是0，条件取false，任何非0的指针的条件之都是true
  + 对于任何两个类型相同的合法指针，可以用相等操作符(==)或不相等操作符(!=)进行比较，结果是布尔类型。如果两个指针存放的地址值相同，则相等：
    + 都为空指针
    + 都指向同一个对象
    + 都指向同一个对象的下一地址
  + void\*指针是一种特殊类型的额指针，可用于存放任意对象的地址。其能做的事情比较有限；
    + 和别的指针比较
    + 作为函数的输入和输出
    + 赋值给另外一个void\*指针
  + 不能直接操作void\*指针所指向的对象,因为并不知道这个对象到底是什么类型，也就无法确定能在这个对象上做哪些操作，我们需要进行强制类型转换才可以进行操作。
  + 一条定义语句可能定义出不同类型的变量：`int i = 1024, *p = &i, &r = i;`  
  + 设计指针或引用的声明，一般有两种写法：
    + 把修饰符和变量标识符写在一起，`int *p1, *p2;`，这种形式着重强调变量具有的符合类型。 
    + 把修饰符和类型名卸载一起，并且每条语句只定义一个变量，`int* p1;`，这种形式着重强调本次声明定义了一种复合类型。  
    上面两种写法都可以，关键是选择并坚持其中的一种写法。
  + 多级指针。
    ```cpp
    int ival = 1024;
    int *p1 = &ival;
    int **ppi = &pi;
    ```
  + 指向指针的引用。
    ```cpp
    int i = 42;
    int *p;
    int *&r = p; //r是一个对指针p的引用
    r = &i; //r引用了一个指针，因此给r赋值&i就是令p指向i
    *r = 0; //解引用r得到i，也就是p指向的对象，将i的值改为0
    ```
  + 要理解r的类型到底是什么，最简单的办法就是从右向左阅读r的定义。离变量名最近的符号(&)对变量的类型有最直接的影响，因此r是一个引用。声明符的其余部分用以确定r的引用的类型是什么，上面的\*说明r引用的是一个指针。最后声明的基本数据类型部分指出r引用的是一个int指针。

### 2.4const限定符
  + const对象一旦创建后其值就不能再改变，所以const对象必须初始化。`const int bufSize = 512`,只能在const类型的对象上执行不改变其内容的操作，编译器在编译过程中把用到该变量的地方都替换成对应的值。  
  + 默认情况下，const对象将被设定为仅在文件内有效，当多个文件中出现了同名的const变量时，其实等同于在不同文件中分别定义了独立的变量。要想可以多个文件共享，对于const变量不管是生面还是定义都要在前面添`estern`关键字，这样只需要一次定义就可以了。
  ```cpp
	extern const int buffSize = fcn(); //定义
	extern const int buffSize; //声明
  ```
  + 对常量的引用，把引用绑定到const对象上，就像绑定到其他对象上一样，与普通引用不同的是，对常量的引用不能被用作修改它所绑定的对象
  	```cpp
		const int ci = 1024;
		const int &ri = ci; //正确，引用及其对应的对象都是常量
		ri = 42; //错误，r1常量引用不可修改内容
		int &r2 = ci; //错误，非常量引用不能指向一个常量对象
	  ```
    因为不允许直接为ci赋值，当然也就不能通过引用去改变ci,因此对r2的初始化是错误的。假设该初始化时合法的，则可以通过r2来改变它引用对象ci的值，这显示时不正确的，因为ci是不能被改变的。
  + 引用的类型必须与其所引用对象的类型一致，但是有两种例外情况。一种是在初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可。
    ```cpp
		double dval = 3.14;
		const in &ri = dval; //正确
    ```
    在这种情况下，ri绑定的是一个临时量对象，实际编译的过程中代码会变为：
		```cpp
		double dval = 3.14;
		const int temp = dval; //由双精度浮点数生成一个临时的整型常量
		const int &ri = dval;
		```
    上面这样的话，ri实际上并没有绑定到dval，所以改变dval的值，ri显示的值并不会被改变。
  + 允许为一个常量引用绑定非常量的对象、字面值，甚至是一个一般表达式：
    ```cpp
		int i = 42;
		const int &r1 = i; //允许将const int&绑定到一个普通的int对象上 i发生改变r1的值也变化
		const int &r2 = 42; // r2是一个常量引用
		const int &r3 = r1 * 2; // r3是一个常量引用
		int &r4 = r1 * 2; //错误，r4是一个普通的非常量引用
    ```
  + 常量引用仅对可参与的操作做出了限定，对于引用对象本身是不是一个常量并未做限定。因为对象也可能是非常量，所以允许通过其他途径改变它的值,r2绑定是合法的，使用r1或者i都可以修改，但是不能通过r2修改。
    ```cpp
		int i = 42; //
		int &r1 = i;
		const int &r2 = i;
		r1 = 0; //正确
		r2 = 0; //错误
    ```

#### 2.4.2 指针和const
  + 指向常量的指针，不能用于改变其所指对象的值，要想存放常量对象的地址，只能使用指向常量的指针：
    ```cpp
		const double pi = 3.14; //pi是一个常量，它的值不能被改变
		double *ptr = &pi; //错误，ptr是一个普通指针，假设这个是合法的，则可以通过ptr修改pi的值，显然是不正确的。
		const double *cptr = &pi; //正确
		*cptr = 42;  //错误，不能修改*cptr的值
		```
		+ 指针的类型必须与所指对象的类型一致，但是有两个例外，第一种例外就是，允许令一个指向常量的指针指向一个非常量对象，和引用类似，指向常量的指针仅仅要求不能通过该指针改变对象的值，而没有规定那个对象的值不能通过其他途径改变。 
		```cpp
		double dval = 3.14;
		cptr = &dval;
		```
   + 常量指针，允许把指针本身定为常量，必须初始化，一旦初始化完成，则它的值（存放在指针中的那个地址）就不能再改变了。
     ```cpp
		 int errNumb = 0;
		 int *const curErr = &errNumb; //curErr是常量指针，将一直指向errNumb
		 const double pi = 3.14159;
		 const double *const pip = &pi; //pip是一个指向常量对象的常量指针，不能通过pip改变其指向对象的值，也不能改变pip的值
		 ```
		 要弄清其含义，最好的办法就是从右向左阅读。离curErr最近的符号是const，意味着curErr本身是一个常量对象，对象的类型由声明符其余部分确定，声明符中下一个是*，意味着curErr是一个常量指针，最后前面的int常量指针指向的是一个int对象。 

#### 2.4.3 顶层const
  + 顶层const表示指针本身是个常量，底层const表示指针所指向的对象是一个常量。 指针是不是常量和指针所指向的是不是一个常量是两个相互独立的问题。  
  + 执行拷贝操作的时候顶层const没有限制，但是拷入和拷出的对象必须具有相同的底层const，或者两个对象的数据类型必须能够转换，一般来说，非常量可以转换为常量。  
  + 用于声明引用的const都是底层const

#### 2.4.4 constexpr和常量表达式
  + 常量表达式指值不会改变并且在编译过程就能得到计算结果的表达式。字面值属于常量表达式，用常量表达式初始化的const对象也是常量表达式，一个对象是不是常量表达式由它的数据类型和初始值共同决定。
    ```cpp
    const max_files = 20; //常量表达式
    const int limit = max_files + 1;  //常量表达式
    int staff_size = 27; //不是常量表达式
    const int sz = get_size(); //不是常量表达式
    ```
    staff_size的初始值式字面值常量，但是它的数据类型知识一个int而不是const int;sz本身是一个常量，但它的具体值直到运行时才能获取到。
  + C++11允许将变量声明为constexpr类型以便由编译器来验证变量的值是否时一个常量表达式。声明为constexpr的变量一定是一个常量，而且必须由常量表达式初始化。
  + 一般来说，如果你认为变量是一个常量表达式，那就将其声明为constexpr类型。
  + 指针和引用都能定义成constexpr，但是它们的初始值受到了很大的限制，一个constexpr指针的初始值必须是nullptr或者0，或者是存储于某个固定地址中的对象，也就是全局变量，引用也是针对的全局变量。
  + 在constexpr声明如果定义了一个指针，限定符constexpr仅对指针有效，与指针所指的对象无关。
  ```cpp
	const int *p = nullptr; //p是指向整型常量的指针
	constexpr int *q = nullptr; //q是一个指向整数的常量指针，constexpr把定义的对象置为了顶层const
  ```

### 2.5 处理类型
#### 2.5.1 类型别名
  + 类型别名和类型名是等价的，只要能使用类型名的地方就能使用类型别名。有两种方式定义类型别名：
  	+ 使用关键字typede:
  	  ```cpp
			type double wages, *p; //wages是double的类型别名，p是double*的类型别名
			```
		+ 使用别名申请using，`using wages = double;`  
	+ 遇到了一条使用类型别名的声明语句的时候，人们往往会错误地尝试把类型别名替换成它本来的样子，以理解该语句的含义，这样是错误的。
		```cpp
		typedef char *pstring;
		const pstring cstr = 0; //cstr是指向char的常量指针
		const string *ps; //ps是一个指针，它的对象是指向char的常量指针。
		```
	  声明语句中用到的pstring时，其基本数据类型是指针，但是如果使用char\*替换pstring的位置，就会认为基本数据类型是char,而\*认为是声明符的一部分。

#### 2.5.2 auto类型说明符
  + auto类型说明符，让编译器通过初始值来推算变量的类型，atuo定义的变量必须有初始值。  
  + 使用auto可以在一条语句中声明多个变量，但是所有变量的初始基本数据类型都必须一致。  
  + 编译器推断出来的auto类型有时候和初始值的类型并不完全一样，特别是当引用被用作初始值的时候。
  + auto一般会忽略顶层的const，同时底层const则会保留下来，如果希望推断出的auto类型是一个顶层const，需要明确指出 `const auto &j = 42;`  

#### 2.5.3 decltype类型指示符
  + decltype，作用是选择并返回操作数的数据类型，在此过程中中，编译器分析表达式并得到它的类型，却不实际计算表达式的值。`decltype(f()) sum = x;`,编译器并不实际调用f()
  + 如果decltype使用的表达式时一个变量，则decltype返回该变量的类型（包括顶层const和引用在内）。引用从来都作为其所指对象的同义词出现，只有在Decltype处是一个例外。
    ```cpp
		const int ci = 0, &cj = ci;
		decltype(ci) x = 0; //x的类型是const int 
		decltype(cj) y = x; //y的类型是const int &,y绑定到变量x
		decltype(cj) z; //错误，z是引用，必须初始化
		```
	+ 有些表达式将向decltype返回一个引用类型，一般来说当这种情况发生时，意味着该表达式的结果对象能作为一条赋值语句的左值。
	  ```cpp
		int i = 42, *p = &i, &r = i;
		decltype(r+0) b; //正确，加法的结果是int，因此b是一个int变量
		decltype(-p) c; //错误,c是int&，必须初始化
		decltype((i)) d; //错误，d是int&,必须初始化
		decltype(i) e;//正确，e是一个未初始化的int
		```
		r是一个引用，因此decltype(r)也是一个引用，如果想让结果类型是r所指的类型，可以把r作为表达式的一部分，如r+0。如果表达式的内容是解引用，则decltype将得到引用类型，因此decltype(*p)得到的类型是int&。如果decltype使用了一个不加括号的变量，则得到的结果就是该变量的类型；如果给变量加上了一层或多层括号，编译器就将其当成一个表达式，就会得到引用类型。  
  + 


	
	












