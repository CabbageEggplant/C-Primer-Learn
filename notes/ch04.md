## 第四章 表达式
### 4.1基础
#### 4.1.1 基本概念
  + 一元运算符、二元运算符、三元运算符
  + 重载运算符包括运算对象的类型和返回值的类型都由该运算符定义，但是运算对象的个数、运算符的优先级和结合律都是无法改变的。
#### 4.1.2 优先级和结合律  
  + 括号无视优先级和结合律

#### 4.1.3 求值顺序
  + 优先级规定了运算对象的组合方式，但是没有说明运算对象按照什么顺序求值，大多数情况下，不会明确求值的顺序，`int i = f1() * f2();`，无法知道是先调用f1还是先调用f2。`cout<<i<<" "<<++i<<endl;`这个也是未定义的，结果可能是0 1也可能是1 1.
  + 有四种运算符明确规定了运算对象的求值顺序：逻辑与（&&）运算符、逻辑或(||)运算符、条件（?:）运算符、逗号(,)运算符  
  + 拿不准的时候最好用括号来强制让表达式的组合关系符合程序逻辑的要求。
  + 如果改变了某个运算符对象的值，在表达式的其他地方不要再使用这个运算对象，但是当改变运算对象的子表达式本身就是另一个子表达式的运算对象时例外。

### 4.2 算数运算符
  + 算数运算符（左结合律）：   
    | 运算符 | 功能 | 用法 |
    | :----- | :----- | :----- |
    | + | 一元正号 | + expr |
    | - | 一元负号 | - expr |
    | **\*** | **乘法** | **expr \* expr** |
    | **/** | **除法** | **expr / expr** |
    | **%** | **求余** | **expr%expr** |
    | + | 加法 | expr + expr |
    | - | 减法 | expr - expr |
    
    上面这些都满足左结合律，也就是当优先级相同的时候，按照从左向右的顺序组合，上面的表格是按照优先级进行分组的。
  + 算数表达式有可能产生未定义的结果：
    + 数学性质本身，例如除数为0
    + 计算机的特点，溢出
  + 参与取余运算符的运算对象必须是整数，除法运算的时候，C++11规定商一律向0取整（直接切除小数部分）
  + 取余运算定义是如果m和n都是整数且n非0，则表达式`(m/n)*n+m%n`的求值结果和m相等，也就是说求余的结果的符号和m相同


### 4.3 逻辑和关系运算符
  + 逻辑运算符和关系运算符：
    | 结合律 | 运算符 | 功能 | 用法 |
    | :----- | :----- | :----- | :----- |
    | 右 | ! | 逻辑非 | !expr | 
    | **左** | **<** | **小于** | **expr<expr** |
    | **左** | **<=** | **小于等于** | **expr<=expr** | 
    | **左** | **>** | **大于** | **expr>expr** |
    | **左** | **>=** | **大于等于** | **expr>=expr** |
    | 左 | == | 相等 | expr==expr |
    | 左 | != | 不相等 | expr!=expr |
    | **左** | **&&** | **逻辑与** | **expr&&expr** |
    | 左 | \|\| | 逻辑或 | expr\|\|expr |
  + 短路求值，当且仅当左侧运算对象无法确定表达式的结果时才会计算右侧运算对象的值：
    + 对于逻辑与运算符来说，当且仅当左侧运算对象为真时才对右侧运算对象求值。
    + 对于逻辑或运算符来说，当且仅当左侧运算对象为假时才对右侧运算对象求值。
  + 逻辑非运算符将运算对象的值取反后返回。
  + 一般使用第一种表示方式，不使用第二种表示方式
    ```cpp
    //第一种
    if(val)
    if(!val)
    //第二种
    if(val == true)
    if(val == false)
    ```

### 4.4 赋值运算符
  + 如果赋值运算符的左右两个运算对象类型不同，则右侧运算对象将转换成左侧运算对象的类型，前提是可以转换的话。
  + C++11允许使用花括号括起来的初始值列表作为赋值语句的右侧运算对象
    ```cpp
    int k = 0;
    k = 3.14;
    k = {3.14}; //错误，窄化转换
    vector<int> vi;
    vi = {1,2,3,4,5};
    ```
  + 赋值运算符满足右结合律。
    ```cpp
    int ival, jval;
    ival = jval = 0;
    
    int ival, *pval;
    ival = pval = 0; //错误，虽然这两个类型都可以使用0进行初始化，但pval=之后是将int*转换为int这样就会报错
    ```
  + 赋值运算优先级低，在条件语句中，赋值部分通常应该加上括号`while((i=get_value()) != 42)`  
  + `a+=b`和`a=a+b`的唯一区别是左侧运算对象的求值次数：使用符合运算符只求值一次；使用普通运算符则求值两次，一次是作为右边子表达式的一部分求值，另一次是赋值运算符的左侧对象求值。  

### 4.5 递增和递减运算符
  + 除非必须，否则不用递增递减的后置版本，因为前置版本的运算符避免了不必要的工作，把值+1或-1直接返回改变了的运算对象；而后置版本需要将原始值存储下来以便于返回这个未修改的内存。
  + `*beg = toupper(*beg++)` 是未定义的行为，因为赋值运算符两端的运算对象都用到了beg，并且右侧的运算对象还改变了beg的值。

### 4.6 成员访问运算符
  + 箭头运算符和点运算符，都是成员访问运算符。  ptr->mem等价于(\*ptr).mem,其中ptr是指针。因为解引用运算符的优先级低于点运算符，所以必须加括号

### 4.7 条件运算符
  + `cond?expr1:expr2;` cond是判断条件的表达式，如果为真，则执行expr1，否则执行expr2，这相当于一个简洁版的if-else语句，条件运算符允许进行嵌套。
  + 条件运算符的优先级非常低，因为通常需要加上括号
    ```cpp
    cout << ((grade < 60) ? "fail" : "pass"); 
    cout << (grade < 60) ? "fail" : "pass";
    cout << grade < 60 ? "fail" : "pass";
    ```
    第一条语句可以正常执行。第二条语句会首先根据grade<60的真假输出0或1，然后根据cout的值输出"fail"或者"true",其会编程cout ? "fail" : "pass";  
    最后一条语句输出grade之后会编程 cout < 60，这明显是错误。  
    
### 4.8 位运算符
  + 位运算符作用于整数类型的运算对象，并把运算对象看成是二进制位的集合
  + 如果运算对象是小整型，则运算对象的值会被自动提升成较大的整数类型。运算对象可以是带符号的，也可以是无符号的。如果运算对象是带符号的，且它的值为负，那么位运算符是如何处理运算对象的“符号位”依赖于机器。而且，此时的左移操作可能会改变符号位的值，因此是一种未定义的行为。  
  + 关于符号位如何处理没有明确的规定，所以强烈建议仅将位运算符用于处理无符号类型。  
  + 移位运算符的右侧对象一定不能为负，而且值得结果严格小于结果得位数，否则就会产生未定义的行为。二进制左移和右移，移出边界之外的位数就被舍弃掉了。 
  + `unsigned char bits = 0233;` 此时bits中的值为`10011011`，bits<<8的结果为`00000000 00000000 10011011 00000000`,类型被提升了，然后左移。  
  + 左移运算符在右侧插入0。右移运算符的行为则依赖于左侧运算对象的类型，如果是无符号的，则左侧插入0，如果是有符号的，在左侧插入符号位的副本或者值为0的二进制位，如何选择视具体情况决定。
  + 位与运算符&&   位或运算符||  位异或运算符^  

### 4.9 sizeof 运算符
  + sizeof运算符返回一条表达式或一个类型名字所占的字节数，返回的值的类型是size_t
  + sizeof(\*p) 在sizeof运算对象中解引用一个无效指针仍然是一种安全的行为，因为指针实际上并没有被真正使用，sizeof不需要真的解引用也能知道它所指对象的类型。
  + sizeof规则
    + 对char或者类型为char的表达式执行sizeof运算，结果得1
    + 对引用类型执行sizeof运算得到被引用对象所占空间的大小
    + 对指针执行sizeof运算得到指针本身所占空间的大小。
    + 对解引用指针执行sizeof运算得到指针指向的对象所占的空间的大小，指针不需要有效
    + 对数组执行sizeof运算得到整个数组所占空间的大小，等价于对数组中所有的元素各执行一次sizeof运算并将所得结果求和。注意sizeof不会将数组编程指针来处理。
    + 对string对象或vector对象执行sizeof运算只返回该类型固定部分得大小，不会计算对象中得元素实际占用了多少空间。  
  + 因为sizeof得返回值是一个常量表达式，所以可以用sizeof的结果声明数组的维度。
    ```cpp
    constexpr size_t sz = sizeof(ia)/sizeof(*ia);
    int arr2[sz];
    ```
  
### 4.10 逗号运算符
  + 逗号运算符有两个运算对象，首先对左侧的表达式求值，然后将求值结果丢弃掉，逗号运算符真正的结果是右侧表达式的值。  

### 4.11 类型转换
  + 隐式转换，无须程序员强制转换，`int ival = 3.14 + 3`  
  + 何时发生隐式转换：
    + 在大多数表达式中，比int类型小的整型值首先提升为较大的整数类型
    + 在条件中，非布尔值转换成布尔值
    + 初始化过程中，初始值转换成变量的类型;在赋值语句中，右侧运算对象转换成左侧运算对象的类型
    + 如果算术运算或关系运算的运算对象有多种类型，需要转换成同一种类型
    + 如第六章介绍的，函数调用时也会发生类型转换
#### 4.11.1 算术转换
  + 算术转换是把一种算术类型转换成另外一种算术类型，算术转换的规则定义了一套类型转换的层次，其中运算符的运算对象转换成最宽的类型。
  + 整型提升：负责把小整数类型转换成较大的整数类型。对于char bool short unsigned char等会转换为int,只要所有可能的值可以存放在int中，否则转换为unsigned int。对于较大char可以转换为long ,unsigned long等类型
  + 如果一个运算对象是无符号类型的，另外一个运算对象是带符号类型的，而且其中无符号类型不小于带符号类型，那么带符号类型转换成无符号类型。如果带符号类型大于无符号类型，此时转换的结果依赖于机器，如果无符号类型的所有值都能存放在该带符号类型中，则无符号类型的运算对象转换成带符号类型，如果不能，则带符号类型转换成无符号类型。




    
    
