## 第四章 表达式
### 4.1基础
#### 4.1.1 基本概念
  + 一元运算符、二元运算符、三元运算符
  + 重载运算符包括运算对象的类型和返回值的类型都由该运算符定义，但是运算对象的个数、运算符的优先级和结合律都是无法改变的。
#### 4.1.2 优先级和结合律  
  + 括号无视优先级和结合律

#### 4.1.3 求值顺序
  + 优先级规定了运算对象的组合方式，但是没有说明运算对象按照什么顺序求值，大多数情况下，不会明确求值的顺序，`int i = f1() * f2();`，无法知道是先调用f1还是先调用f2。`cout<<i<<" "<<++i<<endl;`这个也是未定义的，结果可能是0 1也可能是1 1.
  + 有四种运算符明确规定了运算对象的求值顺序：逻辑与（&&）运算符、逻辑或(||)运算符、条件（?:）运算符、逗号(,)运算符  
  + 拿不准的时候最好用括号来强制让表达式的组合关系符合程序逻辑的要求。
  + 如果改变了某个运算符对象的值，在表达式的其他地方不要再使用这个运算对象，但是当改变运算对象的子表达式本身就是另一个子表达式的运算对象时例外。

### 4.2 算数运算符
  + 算数运算符（左结合律）：   
    | 运算符 | 功能 | 用法 |
    | :----- | :----- | :----- |
    | + | 一元正号 | + expr |
    | - | 一元负号 | - expr |
    | **\*** | **乘法** | **expr \* expr** |
    | **/** | **除法** | **expr / expr** |
    | **%** | **求余** | **expr%expr** |
    | + | 加法 | expr + expr |
    | - | 减法 | expr - expr |
    
    上面这些都满足左结合律，也就是当优先级相同的时候，按照从左向右的顺序组合，上面的表格是按照优先级进行分组的。
  + 算数表达式有可能产生未定义的结果：
    + 数学性质本身，例如除数为0
    + 计算机的特点，溢出
  + 参与取余运算符的运算对象必须是整数，除法运算的时候，C++11规定商一律向0取整（直接切除小数部分）
  + 取余运算定义是如果m和n都是整数且n非0，则表达式`(m/n)*n+m%n`的求值结果和m相等，也就是说求余的结果的符号和m相同


### 4.3 逻辑和关系运算符
  + 逻辑运算符和关系运算符：
    | 结合律 | 运算符 | 功能 | 用法 |
    | :----- | :----- | :----- | :----- |
    | 右 | ! | 逻辑非 | !expr | 
    | **左** | **<** | **小于** | **expr<expr** |
    | **左** | **<=** | **小于等于** | **expr<=expr** | 
    | **左** | **>** | **大于** | **expr>expr** |
    | **左** | **>=** | **大于等于** | **expr>=expr** |
    | 左 | == | 相等 | expr==expr |
    | 左 | != | 不相等 | expr!=expr |
    | **左** | **&&** | **逻辑与** | **expr&&expr** |
    | 左 | \|\| | 逻辑或 | expr\|\|expr |
  + 短路求值，当且仅当左侧运算对象无法确定表达式的结果时才会计算右侧运算对象的值：
    + 对于逻辑与运算符来说，当且仅当左侧运算对象为真时才对右侧运算对象求值。
    + 对于逻辑或运算符来说，当且仅当左侧运算对象为假时才对右侧运算对象求值。
  + 逻辑非运算符将运算对象的值取反后返回。
  + 一般使用第一种表示方式，不使用第二种表示方式
    ```cpp
    //第一种
    if(val)
    if(!val)
    //第二种
    if(val == true)
    if(val == false)
    ```

### 4.4 赋值运算符
  + 如果赋值运算符的左右两个运算对象类型不同，则右侧运算对象将转换成左侧运算对象的类型，前提是可以转换的话。
  + C++11允许使用花括号括起来的初始值列表作为赋值语句的右侧运算对象
    ```cpp
    int k = 0;
    k = 3.14;
    k = {3.14}; //错误，窄化转换
    vector<int> vi;
    vi = {1,2,3,4,5};
    ```
  + 赋值运算符满足右结合律。
    ```cpp
    int ival, jval;
    ival = jval = 0;
    
    int ival, *pval;
    ival = pval = 0; //错误，虽然这两个类型都可以使用0进行初始化，但pval=之后是将int*转换为int这样就会报错
    ```
  + 赋值运算优先级低，在条件语句中，赋值部分通常应该加上括号`while((i=get_value()) != 42)`  
  + `a+=b`和`a=a+b`的唯一区别是左侧运算对象的求值次数：使用符合运算符只求值一次；使用普通运算符则求值两次，一次是作为右边子表达式的一部分求值，另一次是赋值运算符的左侧对象求值。  


    
    
    
